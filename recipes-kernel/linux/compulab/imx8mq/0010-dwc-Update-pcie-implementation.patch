From 7f7da2b32a62ef2df5b6464dc055272a8d84845e Mon Sep 17 00:00:00 2001
From: Valentin Raevsky <valentin@compulab.co.il>
Date: Tue, 13 Jul 2021 14:02:12 +0300
Subject: [PATCH] dwc: Update pcie implementation

Signed-off-by: Valentin Raevsky <valentin@compulab.co.il>
---
 drivers/pci/controller/dwc/pci-imx6.c        | 1537 +++++++++++++-------------
 drivers/pci/controller/dwc/pcie-designware.h |    1 +
 2 files changed, 779 insertions(+), 759 deletions(-)

diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index c655d9de144e..53bb6bd7ffe1 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -10,6 +10,7 @@
 
 #include <dt-bindings/soc/imx8_hsio.h>
 #include <linux/bitfield.h>
+#include <linux/busfreq-imx.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
@@ -19,11 +20,11 @@
 #include <linux/mfd/syscon/imx7-iomuxc-gpr.h>
 #include <linux/module.h>
 #include <linux/of_address.h>
-#include <linux/of_gpio.h>
 #include <linux/of_device.h>
-#include <linux/of_address.h>
+#include <linux/of_gpio.h>
 #include <linux/of_pci.h>
 #include <linux/pci.h>
+#include <linux/phy/phy.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
@@ -31,20 +32,20 @@
 #include <linux/signal.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
-#include <linux/phy/phy.h>
-#include <linux/reset.h>
 #include <linux/pm_domain.h>
 #include <linux/pm_runtime.h>
+#include <linux/reset.h>
 #include "../../pci.h"
 
 #include "pcie-designware.h"
 
 #define IMX8MQ_PCIE_LINK_CAP_REG_OFFSET		0x7c
-#define IMX8MQ_PCIE_LINK_CAP_L1EL_64US		(BIT(18) | BIT(17))
+#define IMX8MQ_PCIE_LINK_CAP_L1EL_64US		GENMASK(18, 17)
 #define IMX8MQ_PCIE_L1SUB_CTRL1_REG_EN_MASK	0xf
 #define IMX8MQ_GPR_PCIE_REF_USE_PAD		BIT(9)
 #define IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN	BIT(10)
 #define IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE	BIT(11)
+#define IMX8MQ_GPR_PCIE_VREG_BYPASS		BIT(12)
 #define IMX8MQ_GPR12_PCIE2_CTRL_DEVICE_TYPE	GENMASK(11, 8)
 #define IMX8MQ_PCIE2_BASE_ADDR			0x33c00000
 #define IMX8_HSIO_PCIEB_BASE_ADDR		0x5f010000
@@ -62,15 +63,16 @@
 #define IMX8MP_GPR_REG2_P_PLL			(0xc << 0)
 #define IMX8MP_GPR_REG2_M_PLL			(0x320 << 6)
 #define IMX8MP_GPR_REG2_S_PLL			(0x4 << 16)
-#define IMX8MP_GPR_REG2_BYPASS_PLL		BIT(21)
 #define IMX8MP_GPR_REG3				0xc
 #define IMX8MP_GPR_REG3_PLL_CKE			BIT(17)
-#define IMX8MP_GPR_REG3_PLL_EXT_BYPASS		BIT(18)
 #define IMX8MP_GPR_REG3_PLL_RST			BIT(31)
+#define IMX8MP_GPR_PCIE_SSC_EN			BIT(16)
+#define IMX8MP_GPR_PCIE_PWR_OFF			BIT(17)
+#define IMX8MP_GPR_PCIE_CMN_RSTN		BIT(18)
+#define IMX8MP_GPR_PCIE_AUX_EN			BIT(19)
 #define IMX8MP_GPR_PCIE_REF_SEL_MASK		GENMASK(25, 24)
-#define IMX8MP_GPR_PCIE_REF_PLL			(BIT(24) | BIT(25))
+#define IMX8MP_GPR_PCIE_REF_PLL_SYS		GENMASK(25, 24)
 #define IMX8MP_GPR_PCIE_REF_EXT_OSC		BIT(25)
-#define IMX8MP_GPR_PCIE_REF_EXT_XO		BIT(24)
 
 #define to_imx6_pcie(x)	dev_get_drvdata((x)->dev)
 
@@ -84,6 +86,15 @@ enum imx6_pcie_variants {
 	IMX8QM,
 	IMX8QXP,
 	IMX8MP,
+	IMX8QXP_EP,
+	IMX8QM_EP,
+	IMX8MQ_EP,
+	IMX8MM_EP,
+	IMX8MP_EP,
+	IMX6SX_EP,
+	IMX7D_EP,
+	IMX6Q_EP,
+	IMX6QP_EP,
 };
 
 #define IMX6_PCIE_FLAG_IMX6_PHY			BIT(0)
@@ -94,6 +105,7 @@ enum imx6_pcie_variants {
 
 struct imx6_pcie_drvdata {
 	enum imx6_pcie_variants variant;
+	enum dw_pcie_device_mode mode;
 	u32 flags;
 	int dbi_length;
 };
@@ -102,8 +114,7 @@ struct imx6_pcie {
 	struct dw_pcie		*pci;
 	int			clkreq_gpio;
 	int			dis_gpio;
-	int			reset_gpio;
-	bool			gpio_active_high;
+	struct gpio_desc	*reset_gpios[5];
 	struct clk		*pcie_bus;
 	struct clk		*pcie_phy;
 	struct clk		*pcie_phy_pclk;
@@ -114,8 +125,9 @@ struct imx6_pcie {
 	struct clk		*pcie_aux;
 	struct clk		*phy_per;
 	struct clk		*misc_per;
+	u32			ext_src_clk_enabled;
+	struct clk		*pcie_ext_src;
 	struct regmap		*iomuxc_gpr;
-	struct regmap		*hsiomix;
 	u32			controller_id;
 	struct reset_control	*pciephy_reset;
 	struct reset_control	*pciephy_perst;
@@ -130,10 +142,10 @@ struct imx6_pcie {
 	u32			hsio_cfg;
 	u32			ext_osc;
 	u32			local_addr;
-	u32			hard_wired;
-	u32			dma_unroll_offset;
+	u32			l1ss_clkreq;
 	int			link_gen;
 	struct regulator	*vpcie;
+	struct regulator	*vph;
 	void __iomem		*phy_base;
 	void __iomem		*hsmix_base;
 
@@ -169,6 +181,7 @@ struct imx6_pcie {
 #define PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK	0xf
 
 #define PCIE_RC_LCSR				0x80
+#define PCIE_RC_LC2SR				0xa0
 
 /* PCIe Port Logic registers (memory-mapped) */
 #define PL_OFFSET 0x700
@@ -187,35 +200,6 @@ struct imx6_pcie {
 
 #define PCIE_LINK_WIDTH_SPEED_CONTROL	0x80C
 
-/* DMA registers */
-#define MAX_PCIE_DMA_CHANNELS	8
-#define DMA_UNROLL_CDM_OFFSET	(0x7 << 19)
-#define DMA_REG_OFFSET		0x970
-#define DMA_CTRL_VIEWPORT_OFF	(DMA_REG_OFFSET + 0x8)
-#define DMA_WRITE_ENGINE_EN_OFF	(DMA_REG_OFFSET + 0xC)
-#define DMA_WRITE_ENGINE_EN	BIT(0)
-#define DMA_WRITE_DOORBELL	(DMA_REG_OFFSET + 0x10)
-#define DMA_READ_ENGINE_EN_OFF	(DMA_REG_OFFSET + 0x2C)
-#define DMA_READ_ENGINE_EN	BIT(0)
-#define DMA_READ_DOORBELL	(DMA_REG_OFFSET + 0x30)
-#define DMA_WRITE_INT_STS	(DMA_REG_OFFSET + 0x4C)
-#define DMA_WRITE_INT_MASK	(DMA_REG_OFFSET + 0x54)
-#define DMA_WRITE_INT_CLR	(DMA_REG_OFFSET + 0x58)
-#define DMA_READ_INT_STS	(DMA_REG_OFFSET + 0xA0)
-#define DMA_READ_INT_MASK	(DMA_REG_OFFSET + 0xA8)
-#define DMA_READ_INT_CLR	(DMA_REG_OFFSET + 0xAC)
-#define DMA_DONE_INT_STS	0xFF
-#define DMA_ABORT_INT_STS	(0xFF << 16)
-#define DMA_VIEWPOT_SEL_OFF	(DMA_REG_OFFSET + 0xFC)
-#define DMA_CHANNEL_CTRL_1	(DMA_REG_OFFSET + 0x100)
-#define DMA_CHANNEL_CTRL_1_LIE	BIT(3)
-#define DMA_CHANNEL_CTRL_2	(DMA_REG_OFFSET + 0x104)
-#define DMA_TRANSFER_SIZE	(DMA_REG_OFFSET + 0x108)
-#define DMA_SAR_LOW		(DMA_REG_OFFSET + 0x10C)
-#define DMA_SAR_HIGH		(DMA_REG_OFFSET + 0x110)
-#define DMA_DAR_LOW		(DMA_REG_OFFSET + 0x114)
-#define DMA_DAR_HIGH		(DMA_REG_OFFSET + 0x118)
-
 /* PHY registers (not memory-mapped) */
 #define PCIE_PHY_ATEOVRD			0x10
 #define  PCIE_PHY_ATEOVRD_EN			BIT(2)
@@ -227,19 +211,11 @@ struct imx6_pcie {
 #define  PCIE_PHY_MPLL_MULTIPLIER_MASK		0x7f
 #define  PCIE_PHY_MPLL_MULTIPLIER_OVRD		BIT(9)
 
-#define PCIE_PHY_RX_ASIC_OUT 0x100D
-#define PCIE_PHY_RX_ASIC_OUT_VALID	(1 << 0)
-
 /* iMX7 PCIe PHY registers */
 #define PCIE_PHY_CMN_REG4		0x14
 /* These are probably the bits that *aren't* DCC_FB_EN */
 #define PCIE_PHY_CMN_REG4_DCC_FB_EN	0x29
 
-#define PCIE_PHY_CMN_REG15	        0x54
-#define PCIE_PHY_CMN_REG15_DLY_4	BIT(2)
-#define PCIE_PHY_CMN_REG15_PLL_PD	BIT(5)
-#define PCIE_PHY_CMN_REG15_OVRD_PLL_PD	BIT(7)
-
 #define PCIE_PHY_CMN_REG24		0x90
 #define PCIE_PHY_CMN_REG24_RX_EQ	BIT(6)
 #define PCIE_PHY_CMN_REG24_RX_EQ_SEL	BIT(3)
@@ -288,7 +264,7 @@ struct imx6_pcie {
 #define IMX8QM_STTS0_LANE0_TX_PLL_LOCK		BIT(4)
 #define IMX8QM_STTS0_LANE1_TX_PLL_LOCK		BIT(12)
 
-#define IMX8QM_PCIE_TYPE_MASK			(0xF << 24)
+#define IMX8QM_PCIE_TYPE_MASK			GENMASK(27, 24)
 
 #define IMX8QM_PHYX2_CTRL0_APB_MASK		0x3
 #define IMX8QM_PHY_APB_RSTN_0			BIT(0)
@@ -314,18 +290,21 @@ struct imx6_pcie {
 #define IMX8MM_GPR_PCIE_POWER_OFF		BIT(17)
 #define IMX8MM_GPR_PCIE_SSC_EN			BIT(16)
 
-static void imx6_pcie_ltssm_disable(struct device *dev);
+int tx_deemph_gen1 = -1;
+int tx_deemph_gen2_3p5db = -1;
+int tx_deemph_gen2_6db = -1;
+int tx_swing_full = -1;
+int tx_swing_low = -1;
+int link_gen;
 
-/*
- * The default value of the reserved ddr memory
- * used to verify EP/RC memory space access operations.
- * The layout of the 1G ddr on SD boards
- * [imx6qdl-sd-ard boards]0x1000_0000 ~ 0x4FFF_FFFF
- * [imx6sx,imx7d platforms]0x8000_0000 ~ 0xBFFF_FFFF
- *
- */
-static u32 ddr_test_region = 0, test_region_size = SZ_2M;
-static bool dma_w_end, dma_r_end, dma_en;
+module_param(tx_deemph_gen1, int, 0644);
+module_param(tx_deemph_gen2_3p5db, int, 0644);
+module_param(tx_deemph_gen2_6db, int, 0644);
+module_param(tx_swing_full, int, 0644);
+module_param(tx_swing_low, int, 0644);
+module_param(link_gen, int, 0644);
+
+static void imx6_pcie_ltssm_disable(struct device *dev);
 
 static bool imx6_pcie_readable_reg(struct device *dev, unsigned int reg)
 {
@@ -333,7 +312,7 @@ static bool imx6_pcie_readable_reg(struct device *dev, unsigned int reg)
 	struct imx6_pcie *imx6_pcie = dev_get_drvdata(dev);
 
 	variant = imx6_pcie->drvdata->variant;
-	if (variant == IMX8QXP) {
+	if (variant == IMX8QXP || variant == IMX8QXP_EP) {
 		switch (reg) {
 		case IMX8QM_CSR_PHYX1_OFFSET:
 		case IMX8QM_CSR_PCIEB_OFFSET:
@@ -376,7 +355,7 @@ static bool imx6_pcie_writeable_reg(struct device *dev, unsigned int reg)
 	struct imx6_pcie *imx6_pcie = dev_get_drvdata(dev);
 
 	variant = imx6_pcie->drvdata->variant;
-	if (variant == IMX8QXP) {
+	if (variant == IMX8QXP || variant == IMX8QXP_EP) {
 		switch (reg) {
 		case IMX8QM_CSR_PHYX1_OFFSET:
 		case IMX8QM_CSR_PCIEB_OFFSET:
@@ -686,6 +665,7 @@ static int imx6_pcie_attach_pd(struct device *dev)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX8QM:
+	case IMX8QM_EP:
 		/*
 		 * PCIA CSR would be touched during the initialization of the
 		 * PCIEB of 8QM.
@@ -713,6 +693,7 @@ static int imx6_pcie_attach_pd(struct device *dev)
 		}
 		/* fall through */
 	case IMX8QXP:
+	case IMX8QXP_EP:
 		pd_dev = dev_pm_domain_attach_by_name(dev, "hsio_gpio");
 		if (IS_ERR(pd_dev)) {
 			ret = PTR_ERR(pd_dev);
@@ -759,6 +740,7 @@ static int imx6_pcie_enable_ref_clk(struct imx6_pcie *imx6_pcie)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX6SX:
+	case IMX6SX_EP:
 		ret = clk_prepare_enable(imx6_pcie->pcie_inbound_axi);
 		if (ret) {
 			dev_err(dev, "unable to enable pcie_axi clock\n");
@@ -769,7 +751,9 @@ static int imx6_pcie_enable_ref_clk(struct imx6_pcie *imx6_pcie)
 				   IMX6SX_GPR12_PCIE_TEST_POWERDOWN, 0);
 		break;
 	case IMX6QP:		/* FALLTHROUGH */
+	case IMX6QP_EP:
 	case IMX6Q:
+	case IMX6Q_EP:
 		/* power up core phy and enable ref clock */
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				   IMX6Q_GPR1_PCIE_TEST_PD, 0 << 18);
@@ -784,10 +768,14 @@ static int imx6_pcie_enable_ref_clk(struct imx6_pcie *imx6_pcie)
 				   IMX6Q_GPR1_PCIE_REF_CLK_EN, 1 << 16);
 		break;
 	case IMX7D:
+	case IMX7D_EP:
 		break;
 	case IMX8MQ:
 	case IMX8MM:
 	case IMX8MP:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
+	case IMX8MP_EP:
 		ret = clk_prepare_enable(imx6_pcie->pcie_aux);
 		if (ret) {
 			dev_err(dev, "unable to enable pcie_aux clock\n");
@@ -807,7 +795,9 @@ static int imx6_pcie_enable_ref_clk(struct imx6_pcie *imx6_pcie)
 				   IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN);
 		break;
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 		ret = clk_prepare_enable(imx6_pcie->pcie_inbound_axi);
 		if (ret) {
 			dev_err(dev, "unable to enable pcie_axi clock\n");
@@ -886,6 +876,7 @@ static void imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX8MP:
+	case IMX8MP_EP:
 		if (phy_init(imx6_pcie->phy) != 0)
 			dev_err(dev, "Waiting for PHY PLL ready timeout!\n");
 		/* wait for core_clk enabled */
@@ -898,6 +889,7 @@ static void imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 		}
 		break;
 	case IMX8MM:
+	case IMX8MM_EP:
 		for (retries = 0; retries < PHY_PLL_LOCK_WAIT_MAX_RETRIES;
 		     retries++) {
 			tmp = readl(imx6_pcie->phy_base + PCIE_PHY_CMN_REG75);
@@ -908,7 +900,9 @@ static void imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 		break;
 
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 		for (retries = 0; retries < PHY_PLL_LOCK_WAIT_MAX_RETRIES;
 		     retries++) {
 			if (imx6_pcie->hsio_cfg == PCIEAX1PCIEBX1SATA) {
@@ -952,6 +946,45 @@ static void imx8_pcie_wait_for_phy_pll_lock(struct imx6_pcie *imx6_pcie)
 		dev_info(dev, "PCIe PLL locked after %d us.\n", retries * 10);
 }
 
+void activate_reset(struct imx6_pcie *imx6_pcie)
+{
+	int i;
+
+	for (i = ARRAY_SIZE(imx6_pcie->reset_gpios) - 1; i >= 0; i--) {
+		if (imx6_pcie->reset_gpios[i])
+			gpiod_set_value_cansleep(imx6_pcie->reset_gpios[i], 1);
+	}
+}
+
+void deactivate_reset(struct imx6_pcie *imx6_pcie)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(imx6_pcie->reset_gpios); i++) {
+		if (imx6_pcie->reset_gpios[i])
+			gpiod_set_value_cansleep(imx6_pcie->reset_gpios[i], 0);
+		else
+			break;
+	}
+	if (imx6_pcie->reset_gpios[0]) {
+		/*
+		 * See 'PCI EXPRESS BASE SPECIFICATION, REV 3.0, SECTION 6.6.1'
+		 * for detailed understanding of the PCIe CR reset logic.
+		 *
+		 * The PCIe #PERST reset line _MUST_ be connected, otherwise
+		 * your design does not conform to the specification. You must
+		 * wait at least 20 mS after de-asserting the #PERST so the
+		 * EP device can do self-initialisation.
+		 *
+		 * In case your #PERST pin is connected to a plain GPIO pin of
+		 * the CPU, you can define CONFIG_PCIE_IMX_PERST_GPIO in your
+		 * board's configuration file and the condition below will
+		 * handle the rest of the reset toggling.
+		 */
+		mdelay(20);
+	}
+}
+
 static void imx6_pcie_clk_enable(struct imx6_pcie *imx6_pcie)
 {
 	int ret;
@@ -986,7 +1019,9 @@ static void imx6_pcie_clk_disable(struct imx6_pcie *imx6_pcie)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX6Q:
+	case IMX6Q_EP:
 	case IMX6QP:
+	case IMX6QP_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				IMX6Q_GPR1_PCIE_REF_CLK_EN, 0);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
@@ -994,28 +1029,35 @@ static void imx6_pcie_clk_disable(struct imx6_pcie *imx6_pcie)
 				IMX6Q_GPR1_PCIE_TEST_PD);
 		break;
 	case IMX6SX:
+	case IMX6SX_EP:
 		clk_disable_unprepare(imx6_pcie->pcie_inbound_axi);
 		break;
 	case IMX7D:
+	case IMX7D_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX7D_GPR12_PCIE_PHY_REFCLK_SEL,
 				   IMX7D_GPR12_PCIE_PHY_REFCLK_SEL);
 		break;
 	case IMX8MP:
+	case IMX8MP_EP:
 		phy_exit(imx6_pcie->phy);
 		phy_power_off(imx6_pcie->phy);
 		/* fall through */
 	case IMX8MQ:
 	case IMX8MM:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
 		clk_disable_unprepare(imx6_pcie->pcie_aux);
 		break;
 	case IMX8QM:
+	case IMX8QM_EP:
 		if (imx6_pcie->controller_id == 1) {
 			clk_disable_unprepare(imx6_pcie->pciex2_per);
 			clk_disable_unprepare(imx6_pcie->pcie_phy_pclk);
 		}
 		/* fall through */
 	case IMX8QXP:
+	case IMX8QXP_EP:
 		clk_disable_unprepare(imx6_pcie->pcie_per);
 		clk_disable_unprepare(imx6_pcie->pcie_inbound_axi);
 		clk_disable_unprepare(imx6_pcie->phy_per);
@@ -1024,8 +1066,18 @@ static void imx6_pcie_clk_disable(struct imx6_pcie *imx6_pcie)
 	default:
 		break;
 	}
+	if (imx6_pcie->ext_src_clk_enabled) {
+		imx6_pcie->ext_src_clk_enabled = 0;
+		clk_disable_unprepare(imx6_pcie->pcie_ext_src);
+	}
 }
 
+#define GPC_CNTR 0
+#define reg32_write(addr, val) __raw_writel(val, addr)
+#define reg32_read(addr)       __raw_readl(addr)
+#define reg32setbit(addr, bitpos) \
+        reg32_write((addr), (reg32_read((addr)) | (1<<(bitpos))))
+
 static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 {
 	u32 val;
@@ -1034,15 +1086,26 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX7D:
+	case IMX7D_EP:
 	case IMX8MQ:
 	case IMX8MM:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
 		reset_control_assert(imx6_pcie->pciephy_reset);
 
 		/* fall through */
 	case IMX8MP:
-		reset_control_assert(imx6_pcie->apps_reset);
+	case IMX8MP_EP:
+		imx6_pcie_ltssm_disable(dev);
+		reset_control_assert(imx6_pcie->pciephy_reset);
+		reset_control_assert(imx6_pcie->pciephy_perst);
 		break;
 	case IMX6SX:
+	case IMX6SX_EP:
+	{
+		struct device_node *gpc_np;
+		void __iomem *gpc_reg;
+
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX6SX_GPR12_PCIE_TEST_POWERDOWN,
 				   IMX6SX_GPR12_PCIE_TEST_POWERDOWN);
@@ -1050,19 +1113,31 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR5,
 				   IMX6SX_GPR5_PCIE_BTNRST_RESET,
 				   IMX6SX_GPR5_PCIE_BTNRST_RESET);
+		/* map GPC register  */
+		gpc_np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
+		gpc_reg = of_iomap(gpc_np, 0);
+		if (gpc_reg)
+			reg32setbit(gpc_reg + GPC_CNTR, 7);
+		else
+			dev_err(dev, "ioremap failed with gpc base\n");
+		iounmap(gpc_reg);
 		break;
+	}
 	case IMX6QP:
+	case IMX6QP_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				   IMX6Q_GPR1_PCIE_SW_RST,
 				   IMX6Q_GPR1_PCIE_SW_RST);
 		break;
 	case IMX6Q:
+	case IMX6Q_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				   IMX6Q_GPR1_PCIE_TEST_PD, 1 << 18);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				   IMX6Q_GPR1_PCIE_REF_CLK_EN, 0 << 16);
 		break;
 	case IMX8QXP:
+	case IMX8QXP_EP:
 		imx6_pcie_clk_enable(imx6_pcie);
 		/*
 		 * Set the over ride low and enabled
@@ -1091,6 +1166,7 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 				IMX8QM_CTRL_POWER_UP_RST_N);
 		break;
 	case IMX8QM:
+	case IMX8QM_EP:
 		imx6_pcie_clk_enable(imx6_pcie);
 		/*
 		 * Set the over ride low and enabled
@@ -1142,6 +1218,33 @@ static void imx6_pcie_assert_core_reset(struct imx6_pcie *imx6_pcie)
 	}
 }
 
+static void imx6_pcie_set_l1_latency(struct imx6_pcie *imx6_pcie)
+{
+	u32 val;
+	struct dw_pcie *pci = imx6_pcie->pci;
+
+	switch (imx6_pcie->drvdata->variant) {
+	case IMX8MQ:
+	case IMX8MM:
+	case IMX8MP:
+		/*
+		 * Configure the L1 latency of rc to less than 64us
+		 * Otherwise, the L1/L1SUB wouldn't be enable by ASPM.
+		 */
+		dw_pcie_dbi_ro_wr_en(pci);
+		val = readl(pci->dbi_base + SZ_1M +
+				IMX8MQ_PCIE_LINK_CAP_REG_OFFSET);
+		val &= ~PCI_EXP_LNKCAP_L1EL;
+		val |= IMX8MQ_PCIE_LINK_CAP_L1EL_64US;
+		writel(val, pci->dbi_base + SZ_1M +
+				IMX8MQ_PCIE_LINK_CAP_REG_OFFSET);
+		dw_pcie_dbi_ro_wr_dis(pci);
+		break;
+	default:
+		break;
+	}
+}
+
 static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 {
 	struct dw_pcie *pci = imx6_pcie->pci;
@@ -1160,8 +1263,11 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 	case IMX8MP:
+	case IMX8MP_EP:
 		/* ClKs had been enabled */
 		break;
 	default:
@@ -1169,17 +1275,14 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		break;
 	}
 
-	/* Some boards don't have PCIe reset GPIO. */
-	if (gpio_is_valid(imx6_pcie->reset_gpio)) {
-		gpio_set_value_cansleep(imx6_pcie->reset_gpio,
-					imx6_pcie->gpio_active_high);
-		msleep(100);
-		gpio_set_value_cansleep(imx6_pcie->reset_gpio,
-					!imx6_pcie->gpio_active_high);
-	}
+	activate_reset(imx6_pcie);
+	if (imx6_pcie->reset_gpios[0])
+		mdelay(20);
+	deactivate_reset(imx6_pcie);
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX8QM:
+	case IMX8QM_EP:
 		if (imx6_pcie->controller_id)
 			/* Set the APB clock masks */
 			regmap_update_bits(imx6_pcie->iomuxc_gpr,
@@ -1190,6 +1293,7 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 				IMX8QM_PHYX2_LPCG_PCLK1_MASK);
 		/* fall through */
 	case IMX8QXP:
+	case IMX8QXP_EP:
 		val = IMX8QM_CSR_PCIEA_OFFSET
 			+ imx6_pcie->controller_id * SZ_64K;
 		/* bit19 PM_REQ_CORE_RST of pciex#_stts0 should be cleared. */
@@ -1210,71 +1314,66 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		break;
 	case IMX8MQ:
 	case IMX8MM:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
 		reset_control_deassert(imx6_pcie->pciephy_reset);
 
 		imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
-		/*
-		 * Set the over ride low and enabled
-		 * make sure that REF_CLK is turned on.
-		 */
-		val = imx6_pcie_grp_offset(imx6_pcie);
-		regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
-				   IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE,
-				   0);
-		regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
-				   IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN,
-				   IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN);
 
-		if (imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_L1SS) {
+		if (imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_L1SS)
 			/*
 			 * Configure the CLK_REQ# high, let the L1SS
 			 * automatically controlled by HW later.
 			 */
 			reset_control_deassert(imx6_pcie->clkreq_reset);
-			/*
-			 * Configure the L1 latency of rc to less than 64us
-			 * Otherwise, the L1/L1SUB wouldn't be enable by ASPM.
-			 */
-			dw_pcie_dbi_ro_wr_en(pci);
-			val = readl(pci->dbi_base + SZ_1M +
-					IMX8MQ_PCIE_LINK_CAP_REG_OFFSET);
-			val &= ~PCI_EXP_LNKCAP_L1EL;
-			val |= IMX8MQ_PCIE_LINK_CAP_L1EL_64US;
-			writel(val, pci->dbi_base + SZ_1M +
-					IMX8MQ_PCIE_LINK_CAP_REG_OFFSET);
-			dw_pcie_dbi_ro_wr_dis(pci);
-		}
+		imx6_pcie_set_l1_latency(imx6_pcie);
 		break;
 	case IMX8MP:
-		if (phy_power_on(imx6_pcie->phy) < 0)
-			dev_err(dev, "Failed to power on PHY!\n");
-		reset_control_assert(imx6_pcie->pciephy_perst);
-		reset_control_assert(imx6_pcie->pciephy_reset);
-		udelay(10);
+	case IMX8MP_EP:
+		reset_control_deassert(imx6_pcie->pciephy_reset);
+		reset_control_deassert(imx6_pcie->pciephy_perst);
+
+		/* release pcie_phy_apb_reset and pcie_phy_init_resetn */
+		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG0);
+		val |= IMX8MP_GPR_REG0_PHY_APB_RST;
+		val |= IMX8MP_GPR_REG0_PHY_INIT_RST;
+		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG0);
+
 		val = imx6_pcie_grp_offset(imx6_pcie);
 		if (imx6_pcie->ext_osc) {
 			/*TODO Configure the external OSC as REF clock */
 			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
 					   IMX8MP_GPR_PCIE_REF_SEL_MASK,
+					   IMX8MP_GPR_PCIE_REF_SEL_MASK);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_AUX_EN,
+					   IMX8MP_GPR_PCIE_AUX_EN);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_SSC_EN, 0);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_PWR_OFF, 0);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_CMN_RSTN, 0);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_REF_SEL_MASK,
 					   IMX8MP_GPR_PCIE_REF_EXT_OSC);
 		} else {
 			/* Configure the internal PLL as REF clock */
 			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
 					   IMX8MP_GPR_PCIE_REF_SEL_MASK,
-					   IMX8MP_GPR_PCIE_REF_PLL);
+					   IMX8MP_GPR_PCIE_REF_PLL_SYS);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_AUX_EN,
+					   IMX8MP_GPR_PCIE_AUX_EN);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_SSC_EN, 0);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_PWR_OFF, 0);
+			regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
+					   IMX8MP_GPR_PCIE_CMN_RSTN, 0);
 		}
-		udelay(100);
-
-		/* release pcie_phy_apb_reset and pcie_phy_init_resetn */
-		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG0);
-		val |= IMX8MP_GPR_REG0_PHY_APB_RST;
-		val |= IMX8MP_GPR_REG0_PHY_INIT_RST;
-		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG0);
-		udelay(1);
-
-		/* turn off pcie ltssm */
-		imx6_pcie_ltssm_disable(dev);
 
+		phy_calibrate(imx6_pcie->phy);
 		/*
 		 * GPR_PCIE_PHY_CTRL_BUS[3:0]
 		 * 0:i_ssc_en 1:i_power_off
@@ -1282,16 +1381,21 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		 */
 		val = imx6_pcie_grp_offset(imx6_pcie);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, val,
-				   BIT(18),
-				   BIT(18));
-		udelay(200);
-
-		reset_control_deassert(imx6_pcie->pciephy_reset);
-		udelay(10);
+				   IMX8MP_GPR_PCIE_CMN_RSTN,
+				   IMX8MP_GPR_PCIE_CMN_RSTN);
 
 		imx8_pcie_wait_for_phy_pll_lock(imx6_pcie);
+
+		if (imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_L1SS)
+			/*
+			 * Configure the CLK_REQ# high, let the L1SS
+			 * automatically controlled by HW later.
+			 */
+			reset_control_deassert(imx6_pcie->clkreq_reset);
+		imx6_pcie_set_l1_latency(imx6_pcie);
 		break;
 	case IMX7D:
+	case IMX7D_EP:
 		reset_control_deassert(imx6_pcie->pciephy_reset);
 
 		/* Workaround for ERR010728, failure of PCI-e PLL VCO to
@@ -1316,16 +1420,19 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 		imx7d_pcie_wait_for_phy_pll_lock(imx6_pcie);
 		break;
 	case IMX6SX:
+	case IMX6SX_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR5,
 				   IMX6SX_GPR5_PCIE_BTNRST_RESET, 0);
 		break;
 	case IMX6QP:
+	case IMX6QP_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,
 				   IMX6Q_GPR1_PCIE_SW_RST, 0);
 
 		usleep_range(200, 500);
 		break;
 	case IMX6Q:		/* Nothing to do */
+	case IMX6Q_EP:
 		break;
 	}
 
@@ -1334,53 +1441,54 @@ static void imx6_pcie_deassert_core_reset(struct imx6_pcie *imx6_pcie)
 
 static void imx6_pcie_configure_type(struct imx6_pcie *imx6_pcie)
 {
-	unsigned int mask, val;
+	unsigned int addr, mask, val, mode;
+	unsigned int variant = imx6_pcie->drvdata->variant;
+	struct dw_pcie *pci = imx6_pcie->pci;
+	struct device *dev = pci->dev;
 
-	if (IS_ENABLED(CONFIG_EP_MODE_IN_EP_RC_SYS)
-			&& (imx6_pcie->hard_wired == 0)) {
-		if (imx6_pcie->drvdata->variant == IMX8QM
-				|| imx6_pcie->drvdata->variant == IMX8QXP) {
-			val = IMX8QM_CSR_PCIEA_OFFSET
-				+ imx6_pcie->controller_id * SZ_64K;
-			regmap_update_bits(imx6_pcie->iomuxc_gpr,
-					val, IMX8QM_PCIE_TYPE_MASK,
-					PCI_EXP_TYPE_ENDPOINT << 24);
-		} else {
-			if (unlikely(imx6_pcie->controller_id))
-				/* iMX8MQ second PCIE */
-				regmap_update_bits(imx6_pcie->iomuxc_gpr,
-						IOMUXC_GPR12,
-						IMX6Q_GPR12_DEVICE_TYPE >> 4,
-						PCI_EXP_TYPE_ENDPOINT << 8);
-			else
-				regmap_update_bits(imx6_pcie->iomuxc_gpr,
-						IOMUXC_GPR12,
-						IMX6Q_GPR12_DEVICE_TYPE,
-						PCI_EXP_TYPE_ENDPOINT << 12);
-		}
-	} else {
-		if (imx6_pcie->drvdata->variant == IMX8QM ||
-		    imx6_pcie->drvdata->variant == IMX8QXP) {
-			val = IMX8QM_CSR_PCIEA_OFFSET
-				+ imx6_pcie->controller_id * SZ_64K;
-			regmap_update_bits(imx6_pcie->iomuxc_gpr,
-					val, IMX8QM_PCIE_TYPE_MASK,
-					PCI_EXP_TYPE_ROOT_PORT << 24);
-		} else if (imx6_pcie->drvdata->variant == IMX8MQ &&
-		    imx6_pcie->controller_id == 1) {
-			mask   = IMX8MQ_GPR12_PCIE2_CTRL_DEVICE_TYPE;
-			val    = FIELD_PREP(IMX8MQ_GPR12_PCIE2_CTRL_DEVICE_TYPE,
-					    PCI_EXP_TYPE_ROOT_PORT);
-			regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
-					mask, val);
+	mode = imx6_pcie->drvdata->mode;
+	switch (mode) {
+	case DW_PCIE_RC_TYPE:
+		mode = PCI_EXP_TYPE_ROOT_PORT;
+		break;
+	case DW_PCIE_EP_TYPE:
+		mode = PCI_EXP_TYPE_ENDPOINT;
+		break;
+	default:
+		dev_err(dev, "INVALID device type %d\n", mode);
+	}
+
+	switch (variant) {
+	case IMX8QM:
+	case IMX8QXP:
+	case IMX8QXP_EP:
+	case IMX8QM_EP:
+		if (imx6_pcie->controller_id)
+			addr = IMX8QM_CSR_PCIEB_OFFSET;
+		else
+			addr = IMX8QM_CSR_PCIEA_OFFSET;
+		mask = IMX8QM_PCIE_TYPE_MASK;
+		val = FIELD_PREP(IMX8QM_PCIE_TYPE_MASK, mode);
+		break;
+	case IMX8MQ:
+	case IMX8MQ_EP:
+		if (imx6_pcie->controller_id == 1) {
+			addr = IOMUXC_GPR12;
+			mask = IMX8MQ_GPR12_PCIE2_CTRL_DEVICE_TYPE;
+			val = FIELD_PREP(IMX8MQ_GPR12_PCIE2_CTRL_DEVICE_TYPE, mode);
 		} else {
+			addr = IOMUXC_GPR12;
 			mask = IMX6Q_GPR12_DEVICE_TYPE;
-			val  = FIELD_PREP(IMX6Q_GPR12_DEVICE_TYPE,
-					  PCI_EXP_TYPE_ROOT_PORT);
-			regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
-					mask, val);
+			val = FIELD_PREP(IMX6Q_GPR12_DEVICE_TYPE, mode);
 		}
+		break;
+	default:
+		addr = IOMUXC_GPR12;
+		mask = IMX6Q_GPR12_DEVICE_TYPE;
+		val = FIELD_PREP(IMX6Q_GPR12_DEVICE_TYPE, mode);
+		break;
 	}
+	regmap_update_bits(imx6_pcie->iomuxc_gpr, addr, mask, val);
 }
 
 static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
@@ -1388,9 +1496,21 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 	int i;
 	unsigned int offset, val;
 
+	if (imx6_pcie->pcie_ext_src) {
+		int ret;
+
+		imx6_pcie->ext_src_clk_enabled = 1;
+		ret = clk_prepare_enable(imx6_pcie->pcie_ext_src);
+		if (ret)
+			dev_err(imx6_pcie->pci->dev,
+				"unable to enable pcie_ext_src clock\n");
+	}
+
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 		if (imx6_pcie->hsio_cfg == PCIEAX2SATA) {
 			/*
 			 * bit 0 rx ena 1.
@@ -1483,14 +1603,16 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 
 		break;
 	case IMX8MM:
+	case IMX8MM_EP:
 		offset = imx6_pcie_grp_offset(imx6_pcie);
 
 		dev_info(imx6_pcie->pci->dev, "%s REF_CLK is used!.\n",
 			 imx6_pcie->ext_osc ? "EXT" : "PLL");
+		regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
+			IMX8MQ_GPR_PCIE_REF_USE_PAD,
+			(imx6_pcie->ext_osc) ? IMX8MQ_GPR_PCIE_REF_USE_PAD : 0);
 		if (imx6_pcie->ext_osc) {
 			regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
-					   IMX8MQ_GPR_PCIE_REF_USE_PAD, 0);
-			regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
 					   IMX8MM_GPR_PCIE_REF_CLK_SEL,
 					   IMX8MM_GPR_PCIE_REF_CLK_SEL);
 			regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
@@ -1512,8 +1634,6 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 		} else {
 			/* Configure the internal PLL as REF clock */
 			regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
-					   IMX8MQ_GPR_PCIE_REF_USE_PAD, 0);
-			regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
 					   IMX8MM_GPR_PCIE_REF_CLK_SEL,
 					   IMX8MM_GPR_PCIE_REF_CLK_SEL);
 			regmap_update_bits(imx6_pcie->iomuxc_gpr, offset,
@@ -1539,6 +1659,14 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 			udelay(200);
 		}
 
+		offset += 4;	/* GPR15 / GPR17 */
+		val = ((imx6_pcie->tx_deemph_gen1 & 0x3f) << 26) |
+			((imx6_pcie->tx_deemph_gen2_3p5db & 0x3f) << 20) |
+			((imx6_pcie->tx_deemph_gen2_6db & 0x3f) << 14) |
+			((imx6_pcie->tx_swing_full & 0x7f) << 7) |
+			((imx6_pcie->tx_swing_low & 0x7f) << 0);
+		regmap_write(imx6_pcie->iomuxc_gpr, offset, val);
+		dev_info(imx6_pcie->pci->dev, "GPR%d=%x\n", offset >> 2, val);
 		/*
 		 * In order to pass the compliance tests.
 		 * Configure the TRSV regiser of iMX8MM PCIe PHY.
@@ -1550,24 +1678,45 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 
 		break;
 	case IMX8MQ:
+	case IMX8MQ_EP:
+		offset = imx6_pcie_grp_offset(imx6_pcie);
 		/*
 		 * TODO: Currently this code assumes external
 		 * oscillator is being used
 		 */
 		regmap_update_bits(imx6_pcie->iomuxc_gpr,
-				   imx6_pcie_grp_offset(imx6_pcie),
+				   offset,
 				   IMX8MQ_GPR_PCIE_REF_USE_PAD,
-				   IMX8MQ_GPR_PCIE_REF_USE_PAD);
+				   (imx6_pcie->ext_osc) ?
+					IMX8MQ_GPR_PCIE_REF_USE_PAD : 0);
+		/*
+		 * Regarding to the datasheet, the PCIE_VPH is suggested
+		 * to be 1.8V. If the PCIE_VPH is supplied by 3.3V, the
+		 * VREG_BYPASS should be cleared to zero.
+		 */
+		if (imx6_pcie->vph &&
+		    regulator_get_voltage(imx6_pcie->vph) > 3000000)
+			regmap_update_bits(imx6_pcie->iomuxc_gpr,
+					   offset,
+					   IMX8MQ_GPR_PCIE_VREG_BYPASS,
+					   0);
+		offset += 4;	/* GPR15 / GPR17 */
+		val = ((imx6_pcie->tx_deemph_gen1 & 0x3f) << 26) |
+			((imx6_pcie->tx_deemph_gen2_3p5db & 0x3f) << 20) |
+			((imx6_pcie->tx_deemph_gen2_6db & 0x3f) << 14) |
+			((imx6_pcie->tx_swing_full & 0x7f) << 7) |
+			((imx6_pcie->tx_swing_low & 0x7f) << 0);
+		regmap_write(imx6_pcie->iomuxc_gpr, offset, val);
+		dev_info(imx6_pcie->pci->dev, "GPR%d=%x\n", offset >> 2, val);
 		break;
 	case IMX8MP:
+	case IMX8MP_EP:
+		phy_power_on(imx6_pcie->phy);
 		dev_info(imx6_pcie->pci->dev, "%s REF_CLK is used!.\n",
 			 imx6_pcie->ext_osc ? "EXT" : "PLL");
 		imx6_pcie_clk_enable(imx6_pcie);
 
-		/*
-		 * Make sure that the bypass_pll of gpr_reg2 is set to
-		 * 1'b1. Set P=12,M=800,S=4 and must set ICP=2'b01.
-		 */
+		/* Set P=12,M=800,S=4 and must set ICP=2'b01. */
 		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG2);
 		val &= ~IMX8MP_GPR_REG2_P_PLL_MASK;
 		val |= IMX8MP_GPR_REG2_P_PLL;
@@ -1575,29 +1724,17 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 		val |= IMX8MP_GPR_REG2_M_PLL;
 		val &= ~IMX8MP_GPR_REG2_S_PLL_MASK;
 		val |= IMX8MP_GPR_REG2_S_PLL;
-		val |= IMX8MP_GPR_REG2_BYPASS_PLL;
 		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG2);
 		/* wait greater than 1/F_FREF =1/2MHZ=0.5us */
 		udelay(1);
-		/* release reset */
+
 		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG3);
 		val |= IMX8MP_GPR_REG3_PLL_RST;
 		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG3);
+		udelay(10);
 
-		/*
-		 * Make sure that the pll_ext_bypass of gpr_reg3 is set
-		 * to 1'b0. set 1 to pll_cke of GPR_REG3
-		 */
-		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG2);
-		val &= ~IMX8MP_GPR_REG2_BYPASS_PLL;
-		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG2);
-
-		/*
-		 * Make sure that the pll_ext_bypass of gpr_reg3 is set
-		 * to 1'b0. set 1 to pll_cke of GPR_REG3
-		 */
+		/* Set 1 to pll_cke of GPR_REG3 */
 		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG3);
-		val &= ~IMX8MP_GPR_REG3_PLL_EXT_BYPASS;
 		val |= IMX8MP_GPR_REG3_PLL_CKE;
 		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG3);
 
@@ -1609,10 +1746,12 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 				break;
 			udelay(10);
 		}
-		if (i >= 100) {
+		if (i >= 100)
 			dev_err(imx6_pcie->pci->dev,
 				"PCIe PHY PLL clock is not locked.\n");
-		}
+		else
+			dev_info(imx6_pcie->pci->dev,
+				"PCIe PHY PLL clock is locked.\n");
 
 		/* pcie_clock_module_en */
 		val = readl(imx6_pcie->hsmix_base + IMX8MP_GPR_REG0);
@@ -1620,10 +1759,12 @@ static void imx6_pcie_init_phy(struct imx6_pcie *imx6_pcie)
 		writel(val, imx6_pcie->hsmix_base + IMX8MP_GPR_REG0);
 		break;
 	case IMX7D:
+	case IMX7D_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX7D_GPR12_PCIE_PHY_REFCLK_SEL, 0);
 		break;
 	case IMX6SX:
+	case IMX6SX_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX6SX_GPR12_PCIE_RX_EQ_MASK,
 				   IMX6SX_GPR12_PCIE_RX_EQ_2);
@@ -1730,20 +1871,29 @@ static void imx6_pcie_ltssm_enable(struct device *dev)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX6Q:
+	case IMX6Q_EP:
 	case IMX6SX:
+	case IMX6SX_EP:
 	case IMX6QP:
+	case IMX6QP_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX6Q_GPR12_PCIE_CTL_2,
 				   IMX6Q_GPR12_PCIE_CTL_2);
 		break;
 	case IMX7D:
+	case IMX7D_EP:
 	case IMX8MQ:
 	case IMX8MM:
 	case IMX8MP:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
+	case IMX8MP_EP:
 		reset_control_deassert(imx6_pcie->apps_reset);
 		break;
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 		/* Bit4 of the CTRL2 */
 		val = IMX8QM_CSR_PCIEA_OFFSET
 			+ imx6_pcie->controller_id * SZ_64K;
@@ -1762,6 +1912,7 @@ static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
 	u32 tmp;
 	int ret;
 
+	dw_pcie_dbi_ro_wr_en(pci);
 	/*
 	 * Force Gen1 operation when starting the link.  In case the link is
 	 * started in Gen2 mode, there is a possibility the devices on the
@@ -1776,17 +1927,27 @@ static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
 
 	/* Start LTSSM. */
 	imx6_pcie_ltssm_enable(dev);
-
 	ret = dw_pcie_wait_for_link(pci);
 	if (ret)
 		goto err_reset_phy;
 
 	if (imx6_pcie->link_gen >= 2) {
+		/* Fill up target link speed before speed change. */
+		tmp = dw_pcie_readl_dbi(pci, PCIE_RC_LC2SR);
+		tmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;
+		tmp |= imx6_pcie->link_gen;
+		dw_pcie_writel_dbi(pci, PCIE_RC_LC2SR, tmp);
+
+		tmp = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);
+		tmp &= ~PORT_LOGIC_SPEED_CHANGE;
+		dw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, tmp);
+#ifndef CONFIG_PCIE_FORCE_GEN1
 		/* Allow Gen2 mode after the link is up. */
 		tmp = dw_pcie_readl_dbi(pci, PCIE_RC_LCR);
 		tmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;
 		tmp |= imx6_pcie->link_gen;
 		dw_pcie_writel_dbi(pci, PCIE_RC_LCR, tmp);
+#endif
 
 		/*
 		 * Start Directed Speed Change so the best possible
@@ -1824,11 +1985,13 @@ static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
 		dev_info(dev, "Link: Gen2 disabled\n");
 	}
 
+	dw_pcie_dbi_ro_wr_dis(pci);
 	tmp = dw_pcie_readl_dbi(pci, PCIE_RC_LCSR);
 	dev_info(dev, "Link up, Gen%i\n", (tmp >> 16) & 0xf);
 	return 0;
 
 err_reset_phy:
+	dw_pcie_dbi_ro_wr_dis(pci);
 	dev_dbg(dev, "PHY DEBUG_R0=0x%08x DEBUG_R1=0x%08x\n",
 		dw_pcie_readl_dbi(pci, PCIE_PORT_DEBUG0),
 		dw_pcie_readl_dbi(pci, PCIE_PORT_DEBUG1));
@@ -1839,6 +2002,8 @@ static int imx6_pcie_establish_link(struct imx6_pcie *imx6_pcie)
 			regulator_disable(imx6_pcie->vpcie);
 		if (imx6_pcie->epdev_on != NULL)
 			regulator_disable(imx6_pcie->epdev_on);
+		if (gpio_is_valid(imx6_pcie->dis_gpio))
+			gpio_set_value_cansleep(imx6_pcie->dis_gpio, 0);
 	}
 
 	return ret;
@@ -1854,6 +2019,7 @@ static void pci_imx_set_msi_en(struct pcie_port *pp)
 		val = dw_pcie_readw_dbi(pci, PCIE_RC_IMX6_MSI_CAP +
 					PCI_MSI_FLAGS);
 		val |= PCI_MSI_FLAGS_ENABLE;
+		val &= ~PCI_MSI_FLAGS_64BIT;
 		dw_pcie_writew_dbi(pci, PCIE_RC_IMX6_MSI_CAP + PCI_MSI_FLAGS,
 				   val);
 		dw_pcie_dbi_ro_wr_dis(pci);
@@ -1865,23 +2031,11 @@ static int imx6_pcie_host_init(struct pcie_port *pp)
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
 
-	if (gpio_is_valid(imx6_pcie->dis_gpio))
-		gpio_set_value_cansleep(imx6_pcie->dis_gpio, 1);
-
-	imx6_pcie_assert_core_reset(imx6_pcie);
-	imx6_pcie_init_phy(imx6_pcie);
-	imx6_pcie_deassert_core_reset(imx6_pcie);
-	imx6_setup_phy_mpll(imx6_pcie);
-	if (!(IS_ENABLED(CONFIG_EP_MODE_IN_EP_RC_SYS)
-			&& (imx6_pcie->hard_wired == 0))) {
-		dw_pcie_setup_rc(pp);
-		pci_imx_set_msi_en(pp);
-		if (imx6_pcie_establish_link(imx6_pcie))
-			return -ENODEV;
-
-		if (IS_ENABLED(CONFIG_PCI_MSI))
-			dw_pcie_msi_init(pp);
-	}
+	dw_pcie_setup_rc(pp);
+	pci_imx_set_msi_en(pp);
+	if (imx6_pcie_establish_link(imx6_pcie))
+		return -ENODEV;
+	dw_pcie_msi_init(pp);
 
 	return 0;
 }
@@ -1917,283 +2071,175 @@ static int imx6_add_pcie_port(struct imx6_pcie *imx6_pcie,
 	return 0;
 }
 
+static int imx6_pcie_start_link(struct dw_pcie *pci)
+{
+	struct device *dev = pci->dev;
+
+	if (dw_pcie_link_up(pci)) {
+		dev_dbg(dev, "link is already up\n");
+		return 0;
+	}
+
+	/* Start LTSSM. */
+	imx6_pcie_ltssm_enable(dev);
+
+	return 0;
+}
+
+static void imx6_pcie_stop_link(struct dw_pcie *pci)
+{
+	struct device *dev = pci->dev;
+
+	/* turn off pcie ltssm */
+	imx6_pcie_ltssm_disable(dev);
+}
+
 static u64 imx6_pcie_cpu_addr_fixup(struct dw_pcie *pcie, u64 cpu_addr)
 {
+	unsigned int offset;
+	struct dw_pcie_ep *ep = &pcie->ep;
 	struct pcie_port *pp = &pcie->pp;
 	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pcie);
 
+	if (imx6_pcie->drvdata->mode == DW_PCIE_RC_TYPE)
+		offset = pp->mem_base;
+	else
+		offset = ep->phys_base;
+
 	if (imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_IMX6_CPU_ADDR_FIXUP)
-		return (cpu_addr + imx6_pcie->local_addr - pp->mem_base);
+		return (cpu_addr + imx6_pcie->local_addr - offset);
 	else
 		return cpu_addr;
 }
 
 static const struct dw_pcie_ops dw_pcie_ops = {
-	/* No special ops needed, but pcie-designware still expects this struct */
+	.start_link = imx6_pcie_start_link,
+	.stop_link = imx6_pcie_stop_link,
 	.cpu_addr_fixup = imx6_pcie_cpu_addr_fixup,
 };
 
-static ssize_t ep_bar0_addr_show(struct device *dev,
-		struct device_attribute *attr, char *buf)
+static void imx_pcie_ep_init(struct dw_pcie_ep *ep)
 {
-	struct imx6_pcie *imx6_pcie = dev_get_drvdata(dev);
-	struct dw_pcie *pci = imx6_pcie->pci;
+	enum pci_barno bar;
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
 
-	return sprintf(buf, "imx-pcie-bar0-addr-info start 0x%08x\n",
-			readl(pci->dbi_base + PCI_BASE_ADDRESS_0));
+	for (bar = BAR_0; bar <= BAR_5; bar++)
+		dw_pcie_ep_reset_bar(pci, bar);
 }
 
-static ssize_t ep_bar0_addr_store(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
+static int imx_pcie_ep_raise_irq(struct dw_pcie_ep *ep, u8 func_no,
+				   enum pci_epc_irq_type type,
+				   u16 interrupt_num)
 {
-	u32 bar_start;
-	struct imx6_pcie *imx6_pcie = dev_get_drvdata(dev);
-	struct dw_pcie *pci = imx6_pcie->pci;
-
-	if (sscanf(buf, "%x\n", &bar_start) != 1)
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+
+	switch (type) {
+	case PCI_EPC_IRQ_LEGACY:
+		return dw_pcie_ep_raise_legacy_irq(ep, func_no);
+	case PCI_EPC_IRQ_MSI:
+		return dw_pcie_ep_raise_msi_irq(ep, func_no, interrupt_num);
+	case PCI_EPC_IRQ_MSIX:
+		return dw_pcie_ep_raise_msix_irq(ep, func_no, interrupt_num);
+	default:
+		dev_err(pci->dev, "UNKNOWN IRQ type\n");
 		return -EINVAL;
-	writel(bar_start, pci->dbi_base + PCI_BASE_ADDRESS_0);
+	}
 
-	return count;
+	return 0;
 }
 
-static void imx6_pcie_regions_setup(struct device *dev)
-{
-	struct imx6_pcie *imx6_pcie = dev_get_drvdata(dev);
-	struct dw_pcie *pci = imx6_pcie->pci;
-	struct pcie_port *pp = &pci->pp;
+/*
+ * iMX8QM/iMXQXP: Bar1/3/5 are reserved.
+ */
+static const struct pci_epc_features imx8q_pcie_epc_features = {
+	.linkup_notifier = false,
+	.msi_capable = true,
+	.msix_capable = false,
+	.reserved_bar = 1 << BAR_1 | 1 << BAR_3 | 1 << BAR_5,
+};
 
-	dw_pcie_dbi_ro_wr_en(pci);
+static const struct pci_epc_features imx8m_pcie_epc_features = {
+	.linkup_notifier = false,
+	.msi_capable = true,
+	.msix_capable = false,
+	.reserved_bar = 1 << BAR_1 | 1 << BAR_3,
+	.align = SZ_64K,
+};
 
-	switch (imx6_pcie->drvdata->variant) {
-	case IMX8QM:
-	case IMX8QXP:
-	case IMX8MQ:
-	case IMX8MM:
-	case IMX8MP:
-		/*
-		 * RPMSG reserved 4Mbytes, but only used up to 2Mbytes.
-		 * The left 2Mbytes can be used here.
-		 */
-		if (ddr_test_region == 0)
-			dev_err(dev, "invalid ddr test region.\n");
-		break;
-	case IMX6SX:
-	case IMX7D:
-		ddr_test_region = 0xb0000000;
-		break;
+static const struct pci_epc_features imx6q_pcie_epc_features = {
+	.linkup_notifier = false,
+	.msi_capable = true,
+	.msix_capable = false,
+	.reserved_bar = 1 << BAR_0 | 1 << BAR_1 | 1 << BAR_2,
+	.align = SZ_64K,
+};
 
-	case IMX6Q:
-	case IMX6QP:
-		ddr_test_region = 0x40000000;
-		break;
-	}
-	dev_info(dev, "ddr_test_region is 0x%08x.\n", ddr_test_region);
+static const struct pci_epc_features*
+imx_pcie_ep_get_features(struct dw_pcie_ep *ep)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_ep(ep);
+	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
 
-	dw_pcie_prog_outbound_atu(pci, 0, 0, pp->mem_base,
-				  ddr_test_region, test_region_size);
+	switch (imx6_pcie->drvdata->variant) {
+	case IMX8QM_EP:
+	case IMX8QXP_EP:
+		return &imx8q_pcie_epc_features;
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
+	case IMX8MP_EP:
+	case IMX7D_EP:
+	case IMX6SX_EP:
+		return &imx8m_pcie_epc_features;
+	default:
+		return &imx6q_pcie_epc_features;
+	}
 }
 
-static DEVICE_ATTR_RW(ep_bar0_addr);
-
-static struct attribute *imx6_pcie_ep_attrs[] = {
-	&dev_attr_ep_bar0_addr.attr,
-	NULL
-};
-
-static struct attribute_group imx6_pcie_attrgroup = {
-	.attrs	= imx6_pcie_ep_attrs,
+static const struct dw_pcie_ep_ops pcie_ep_ops = {
+	.ep_init = imx_pcie_ep_init,
+	.raise_irq = imx_pcie_ep_raise_irq,
+	.get_features = imx_pcie_ep_get_features,
 };
 
-static void imx6_pcie_setup_ep(struct dw_pcie *pci, unsigned int bar_offset)
+static int imx_add_pcie_ep(struct imx6_pcie *imx6_pcie,
+					struct platform_device *pdev)
 {
 	int ret;
-	u32 val;
-	u32 lanes;
-	struct device_node *np = pci->dev->of_node;
+	unsigned int pcie_dbi2_offset;
+	struct dw_pcie_ep *ep;
+	struct resource *res;
+	struct dw_pcie *pci = imx6_pcie->pci;
+	struct device *dev = pci->dev;
 
-	ret = of_property_read_u32(np, "num-lanes", &lanes);
-	if (ret)
-		lanes = 0;
+	ep = &pci->ep;
+	ep->ops = &pcie_ep_ops;
 
-	/* set the number of lanes */
-	val = dw_pcie_readl_dbi(pci, PCIE_PORT_LINK_CONTROL);
-	val &= ~PORT_LINK_MODE_MASK;
-	switch (lanes) {
-	case 1:
-		val |= PORT_LINK_MODE_1_LANES;
+	switch (imx6_pcie->drvdata->variant) {
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
+	case IMX8MP_EP:
+		pcie_dbi2_offset = SZ_1M;
 		break;
 	default:
-		dev_err(pci->dev, "num-lanes %u: invalid value\n", lanes);
-		return;
-	}
-	dw_pcie_writel_dbi(pci, PCIE_PORT_LINK_CONTROL, val);
-
-	/* set link width speed control register */
-	val = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);
-	val &= ~PORT_LOGIC_LINK_WIDTH_MASK;
-	switch (lanes) {
-	case 1:
-		val |= PORT_LOGIC_LINK_WIDTH_1_LANES;
+		pcie_dbi2_offset = SZ_4K;
 		break;
-	default:
-		dev_err(pci->dev, "num-lanes %u: invalid value\n", lanes);
-		return;
 	}
-	dw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, val);
-
-	/* get iATU unroll support */
-	val = dw_pcie_readl_dbi(pci, PCIE_ATU_VIEWPORT);
-	if (val == 0xffffffff) {
-		pci->iatu_unroll_enabled = 1;
-		if (!pci->atu_base)
-			pci->atu_base = pci->dbi_base + DEFAULT_DBI_ATU_OFFSET;
-	}
-	dev_info(pci->dev, "iATU unroll: %s\n",
-		pci->iatu_unroll_enabled ? "enabled" : "disabled");
-
-	/* CMD reg:I/O space, MEM space, and Bus Master Enable */
-	writel(readl(pci->dbi_base + PCI_COMMAND)
-			| PCI_COMMAND_IO
-			| PCI_COMMAND_MEMORY
-			| PCI_COMMAND_MASTER,
-			pci->dbi_base + PCI_COMMAND);
-
-	/*
-	 * configure the class_rev(emaluate one memory ram ep device),
-	 * bar0 and bar1 of ep
-	 */
-	writel(0xdeadbeaf, pci->dbi_base + PCI_VENDOR_ID);
-	writel((readl(pci->dbi_base + PCI_CLASS_REVISION) & 0xFFFF)
-			| (PCI_CLASS_MEMORY_RAM	<< 16),
-			pci->dbi_base + PCI_CLASS_REVISION);
-	writel(0xdeadbeaf, pci->dbi_base
-			+ PCI_SUBSYSTEM_VENDOR_ID);
-
-	/* 32bit none-prefetchable 8M bytes memory on bar0 */
-	writel(0x0, pci->dbi_base + PCI_BASE_ADDRESS_0);
-	writel(SZ_8M - 1, pci->dbi_base + bar_offset
-			+ PCI_BASE_ADDRESS_0);
-
-	/* None used bar1 */
-	writel(0x0, pci->dbi_base + PCI_BASE_ADDRESS_1);
-	writel(0, pci->dbi_base + bar_offset + PCI_BASE_ADDRESS_1);
-
-	/* 4K bytes IO on bar2 */
-	writel(0x1, pci->dbi_base + PCI_BASE_ADDRESS_2);
-	writel(SZ_4K - 1, pci->dbi_base + bar_offset +
-			PCI_BASE_ADDRESS_2);
-
-	/*
-	 * 32bit prefetchable 1M bytes memory on bar3
-	 * FIXME BAR MASK3 is not changeable, the size
-	 * is fixed to 256 bytes.
-	 */
-	writel(0x8, pci->dbi_base + PCI_BASE_ADDRESS_3);
-	writel(SZ_1M - 1, pci->dbi_base + bar_offset
-			+ PCI_BASE_ADDRESS_3);
-
-	/*
-	 * 64bit prefetchable 1M bytes memory on bar4-5.
-	 * FIXME BAR4,5 are not enabled yet
-	 */
-	writel(0xc, pci->dbi_base + PCI_BASE_ADDRESS_4);
-	writel(SZ_1M - 1, pci->dbi_base + bar_offset
-			+ PCI_BASE_ADDRESS_4);
-	writel(0, pci->dbi_base + bar_offset + PCI_BASE_ADDRESS_5);
-}
-
-static irqreturn_t imx6_pcie_dma_isr(int irq, void *param)
-{
-	u32 irqs, offset;
-	struct pcie_port *pp = (struct pcie_port *)param;
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
-
-	offset = imx6_pcie->dma_unroll_offset;
-
-	/* check write isr */
-	irqs = readl(pci->dbi_base + offset + DMA_WRITE_INT_STS);
-	if (irqs & DMA_DONE_INT_STS) {
-		/* write 1 clear */
-		writel(irqs & DMA_DONE_INT_STS,
-				pci->dbi_base + offset + DMA_WRITE_INT_CLR);
-		dma_w_end = 1;
-	} else if (irqs & DMA_ABORT_INT_STS) {
-		pr_info("imx pcie dma write error 0x%0x.\n", irqs);
-	}
-	/* check read isr */
-	irqs = readl(pci->dbi_base + offset + DMA_READ_INT_STS);
-	if (irqs & DMA_DONE_INT_STS) {
-		/* write 1 clear */
-		writel(irqs & DMA_DONE_INT_STS,
-				pci->dbi_base + offset + DMA_READ_INT_CLR);
-		dma_r_end = 1;
-	} else if (irqs & DMA_ABORT_INT_STS) {
-		pr_info("imx pcie dma read error 0x%0x.", irqs);
-	}
-	return IRQ_HANDLED;
-}
-
-/**
- * imx6_pcie_local_dma_start - Start one local iMX PCIE DMA.
- * @pp: the port start the dma transmission.
- * @dir: direction of the dma, 1 read, 0 write;
- * @chl: the channel num of the iMX PCIE DMA(0 - 7).
- * @src: source DMA address.
- * @dst: destination DMA address.
- * @len: transfer length.
- */
-static int imx6_pcie_local_dma_start(struct pcie_port *pp, bool dir,
-		unsigned int chl, dma_addr_t src, dma_addr_t dst,
-		unsigned int len)
-{
-	u32 offset, doorbell, unroll_cal;
-	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
-	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
-
-	if (pp == NULL)
-		return -EINVAL;
-	if (chl > MAX_PCIE_DMA_CHANNELS)
+	pci->dbi_base2 = pci->dbi_base + pcie_dbi2_offset;
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "addr_space");
+	if (!res)
 		return -EINVAL;
 
-	offset = imx6_pcie->dma_unroll_offset;
-	/* enable dma engine, dir 1:read. 0:write. */
-	if (dir)
-		writel(DMA_READ_ENGINE_EN,
-				pci->dbi_base + offset
-				+ DMA_READ_ENGINE_EN_OFF);
-	else
-		writel(DMA_WRITE_ENGINE_EN,
-				pci->dbi_base + offset
-				+ DMA_WRITE_ENGINE_EN_OFF);
-	writel(0x0, pci->dbi_base + offset + DMA_WRITE_INT_MASK);
-	writel(0x0, pci->dbi_base + offset + DMA_READ_INT_MASK);
-	 /* ch dir and ch num */
-	if (offset == 0) {
-		writel((dir << 31) | chl, pci->dbi_base + DMA_VIEWPOT_SEL_OFF);
-		writel(DMA_CHANNEL_CTRL_1_LIE,
-				pci->dbi_base + DMA_CHANNEL_CTRL_1);
-		writel(0x0, pci->dbi_base + DMA_CHANNEL_CTRL_2);
-		writel(len, pci->dbi_base + DMA_TRANSFER_SIZE);
-		writel((u32)src, pci->dbi_base + DMA_SAR_LOW);
-		writel(0x0, pci->dbi_base + DMA_SAR_HIGH);
-		writel((u32)dst, pci->dbi_base + DMA_DAR_LOW);
-		writel(0x0, pci->dbi_base + DMA_DAR_HIGH);
-	} else {
-		unroll_cal = DMA_UNROLL_CDM_OFFSET
-			+ 0x200 * (chl + 1) + 0x100 * dir;
-		writel(DMA_CHANNEL_CTRL_1_LIE, pci->dbi_base + unroll_cal);
-		writel(0x0, pci->dbi_base + unroll_cal + 0x4);
-		writel(len, pci->dbi_base + unroll_cal + 0x8);
-		writel((u32)src, pci->dbi_base + unroll_cal + 0xc);
-		writel(0x0, pci->dbi_base + unroll_cal + 0x10);
-		writel((u32)dst, pci->dbi_base + unroll_cal + 0x14);
-		writel(0x0, pci->dbi_base + unroll_cal + 0x18);
-	}
+	ep->phys_base = res->start;
+	ep->addr_size = resource_size(res);
+	ep->page_size = SZ_64K;
 
-	doorbell = dir ? DMA_READ_DOORBELL : DMA_WRITE_DOORBELL;
-	writel(chl, pci->dbi_base + offset + doorbell);
+	ret = dw_pcie_ep_init(ep);
+	if (ret) {
+		dev_err(dev, "failed to initialize endpoint\n");
+		return ret;
+	}
+	/* Start LTSSM. */
+	imx6_pcie_ltssm_enable(dev);
 
 	return 0;
 }
@@ -2205,18 +2251,26 @@ static void imx6_pcie_ltssm_disable(struct device *dev)
 
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX6SX:
+	case IMX6SX_EP:
 	case IMX6QP:
+	case IMX6QP_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX6Q_GPR12_PCIE_CTL_2, 0);
 		break;
 	case IMX7D:
+	case IMX7D_EP:
 	case IMX8MQ:
 	case IMX8MM:
 	case IMX8MP:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
+	case IMX8MP_EP:
 		reset_control_assert(imx6_pcie->apps_reset);
 		break;
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 		/* Bit4 of the CTRL2 */
 		val = IMX8QM_CSR_PCIEA_OFFSET
 			+ imx6_pcie->controller_id * SZ_64K;
@@ -2232,6 +2286,56 @@ static void imx6_pcie_ltssm_disable(struct device *dev)
 	}
 }
 
+static ssize_t bus_freq_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	u32 bus_freq;
+
+	ret = sscanf(buf, "%x\n", &bus_freq);
+	if (ret != 1)
+		return -EINVAL;
+	if (bus_freq) {
+		dev_info(dev, "pcie request bus freq high.\n");
+		request_bus_freq(BUS_FREQ_HIGH);
+	} else {
+		dev_info(dev, "pcie release bus freq high.\n");
+		release_bus_freq(BUS_FREQ_HIGH);
+	}
+
+	return count;
+}
+static DEVICE_ATTR_WO(bus_freq);
+
+static struct attribute *imx_pcie_rc_attrs[] = {
+	&dev_attr_bus_freq.attr,
+	NULL
+};
+
+static struct attribute_group imx_pcie_attrgroup = {
+	.attrs	= imx_pcie_rc_attrs,
+};
+
+static void imx6_pcie_clkreq_enable(struct imx6_pcie *imx6_pcie)
+{
+	/*
+	 * If the L1SS is supported, disable the over ride after link up.
+	 * Let the the CLK_REQ# controlled by HW L1SS automatically.
+	 */
+	switch (imx6_pcie->drvdata->variant) {
+	case IMX8MQ:
+	case IMX8MM:
+	case IMX8MP:
+		regmap_update_bits(imx6_pcie->iomuxc_gpr,
+			imx6_pcie_grp_offset(imx6_pcie),
+			IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN,
+			0);
+		break;
+	default:
+		break;
+	};
+}
+
 #ifdef CONFIG_PM_SLEEP
 static void imx6_pcie_pm_turnoff(struct imx6_pcie *imx6_pcie)
 {
@@ -2249,6 +2353,7 @@ static void imx6_pcie_pm_turnoff(struct imx6_pcie *imx6_pcie)
 	/* Others poke directly at IOMUXC registers */
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX6SX:
+	case IMX6SX_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				IMX6SX_GPR12_PCIE_PM_TURN_OFF,
 				IMX6SX_GPR12_PCIE_PM_TURN_OFF);
@@ -2256,6 +2361,7 @@ static void imx6_pcie_pm_turnoff(struct imx6_pcie *imx6_pcie)
 				IMX6SX_GPR12_PCIE_PM_TURN_OFF, 0);
 		break;
 	case IMX6QP:
+	case IMX6QP_EP:
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,
 				   IMX6SX_GPR12_PCIE_PM_TURN_OFF,
 				   IMX6SX_GPR12_PCIE_PM_TURN_OFF);
@@ -2263,7 +2369,9 @@ static void imx6_pcie_pm_turnoff(struct imx6_pcie *imx6_pcie)
 				   IMX6SX_GPR12_PCIE_PM_TURN_OFF, 0);
 		break;
 	case IMX8QXP:
+	case IMX8QXP_EP:
 	case IMX8QM:
+	case IMX8QM_EP:
 		dst = IMX8QM_CSR_PCIEA_OFFSET + imx6_pcie->controller_id * SZ_64K;
 		regmap_update_bits(imx6_pcie->iomuxc_gpr,
 				dst + IMX8QM_CSR_PCIE_CTRL2_OFFSET,
@@ -2358,6 +2466,8 @@ static int imx6_pcie_resume_noirq(struct device *dev)
 		ret = imx6_pcie_establish_link(imx6_pcie);
 		if (ret < 0)
 			dev_info(dev, "pcie link is down after resume.\n");
+		if (imx6_pcie->l1ss_clkreq)
+			imx6_pcie_clkreq_enable(imx6_pcie);
 	}
 
 	return 0;
@@ -2380,7 +2490,8 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 	void __iomem *iomem;
 	struct regmap_config regconfig = imx6_pcie_regconfig;
 	int ret;
-	u32 reg;
+	u32 val;
+	int i;
 
 	imx6_pcie = devm_kzalloc(dev, sizeof(*imx6_pcie), GFP_KERNEL);
 	if (!imx6_pcie)
@@ -2417,7 +2528,7 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 	if (IS_ERR(imx6_pcie->phy)) {
 		if (PTR_ERR(imx6_pcie->phy) == -EPROBE_DEFER)
 			return -EPROBE_DEFER;
-		dev_info(dev, "couldn't get pcie-phy\n");
+		/* Set NULL if there is no pcie-phy */
 		imx6_pcie->phy = NULL;
 	}
 
@@ -2447,29 +2558,17 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		imx6_pcie->hsio_cfg = 0;
 	if (of_property_read_u32(node, "ext_osc", &imx6_pcie->ext_osc) < 0)
 		imx6_pcie->ext_osc = 0;
-
 	if (of_property_read_u32(node, "local-addr", &imx6_pcie->local_addr))
 		imx6_pcie->local_addr = 0;
-	if (of_property_read_u32(node, "hard-wired", &imx6_pcie->hard_wired))
-		imx6_pcie->hard_wired = 0;
-
-	np = of_parse_phandle(node, "reserved-region", 0);
-	if (np) {
-		struct resource res;
-
-		if (of_address_to_resource(np, 0, &res)) {
-			dev_err(dev, "failed to get reserved region address\n");
-			of_node_put(np);
-			return -EINVAL;
-		}
-		ddr_test_region = res.start + SZ_2M;
-		of_node_put(np);
-	}
+	if (of_property_read_bool(node, "l1ss-disabled"))
+		imx6_pcie->l1ss_clkreq = 0;
+	else
+		imx6_pcie->l1ss_clkreq = 1;
 
 	/* Fetch GPIOs */
 	imx6_pcie->clkreq_gpio = of_get_named_gpio(node, "clkreq-gpio", 0);
 	if (gpio_is_valid(imx6_pcie->clkreq_gpio)) {
-		devm_gpio_request_one(&pdev->dev, imx6_pcie->clkreq_gpio,
+		devm_gpio_request_one(dev, imx6_pcie->clkreq_gpio,
 				      GPIOF_OUT_INIT_LOW, "PCIe CLKREQ");
 	} else if (imx6_pcie->clkreq_gpio == -EPROBE_DEFER) {
 		return imx6_pcie->clkreq_gpio;
@@ -2477,36 +2576,29 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 
 	imx6_pcie->dis_gpio = of_get_named_gpio(node, "disable-gpio", 0);
 	if (gpio_is_valid(imx6_pcie->dis_gpio)) {
-		ret = devm_gpio_request_one(&pdev->dev, imx6_pcie->dis_gpio,
+		ret = devm_gpio_request_one(dev, imx6_pcie->dis_gpio,
 					    GPIOF_OUT_INIT_LOW, "PCIe DIS");
 		if (ret) {
-			dev_err(&pdev->dev, "unable to get disable gpio\n");
+			dev_err(dev, "unable to get disable gpio\n");
 			return ret;
 		}
 	} else if (imx6_pcie->dis_gpio == -EPROBE_DEFER) {
 		return imx6_pcie->dis_gpio;
 	}
-
-	imx6_pcie->epdev_on = devm_regulator_get(&pdev->dev,
-						 "epdev_on");
+	imx6_pcie->epdev_on = devm_regulator_get(dev, "epdev_on");
 	if (IS_ERR(imx6_pcie->epdev_on))
 		return -EPROBE_DEFER;
 
-	imx6_pcie->reset_gpio = of_get_named_gpio(node, "reset-gpio", 0);
-	imx6_pcie->gpio_active_high = of_property_read_bool(node,
-						"reset-gpio-active-high");
-	if (gpio_is_valid(imx6_pcie->reset_gpio)) {
-		ret = devm_gpio_request_one(dev, imx6_pcie->reset_gpio,
-				imx6_pcie->gpio_active_high ?
-					GPIOF_OUT_INIT_HIGH :
-					GPIOF_OUT_INIT_LOW,
-				"PCIe reset");
-		if (ret) {
-			dev_err(dev, "unable to get reset gpio\n");
-			return ret;
-		}
-	} else if (imx6_pcie->reset_gpio == -EPROBE_DEFER) {
-		return imx6_pcie->reset_gpio;
+	for (i = 0; i < ARRAY_SIZE(imx6_pcie->reset_gpios); i++) {
+		struct gpio_desc *gd = devm_gpiod_get_index(dev, "reset", i,
+							    GPIOD_OUT_HIGH);
+
+		if (PTR_ERR(gd) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		if (IS_ERR(gd))
+			break;
+		imx6_pcie->reset_gpios[i] = gd;
+		pr_info("%s: reset gp %d\n", __func__, desc_to_gpio(gd));
 	}
 
 	/* Fetch clocks */
@@ -2528,8 +2620,19 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		return PTR_ERR(imx6_pcie->pcie);
 	}
 
+	imx6_pcie->pcie_ext_src = devm_clk_get(dev,
+			"pcie_ext_src");
+	if (IS_ERR(imx6_pcie->pcie_ext_src)) {
+		if (PTR_ERR(imx6_pcie->pcie_ext_src) == -EPROBE_DEFER)
+			return PTR_ERR(imx6_pcie->pcie_ext_src);
+		imx6_pcie->pcie_ext_src = NULL;
+		dev_info(dev,
+			"pcie_ext_src clk src missing or invalid\n");
+	}
+
 	switch (imx6_pcie->drvdata->variant) {
 	case IMX6SX:
+	case IMX6SX_EP:
 		imx6_pcie->pcie_inbound_axi = devm_clk_get(dev,
 							   "pcie_inbound_axi");
 		if (IS_ERR(imx6_pcie->pcie_inbound_axi)) {
@@ -2538,6 +2641,7 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		}
 		break;
 	case IMX8MP:
+	case IMX8MP_EP:
 		imx6_pcie->pciephy_perst = devm_reset_control_get_exclusive(dev,
 									    "pciephy_perst");
 		if (IS_ERR(imx6_pcie->pciephy_perst)) {
@@ -2547,6 +2651,8 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		/* fall through */
 	case IMX8MQ:
 	case IMX8MM:
+	case IMX8MQ_EP:
+	case IMX8MM_EP:
 		imx6_pcie->pcie_aux = devm_clk_get(dev, "pcie_aux");
 		if (IS_ERR(imx6_pcie->pcie_aux)) {
 			dev_err(dev, "pcie_aux clock source missing or invalid\n");
@@ -2555,6 +2661,7 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 
 		/* fall through */
 	case IMX7D:
+	case IMX7D_EP:
 		if (dbi_base->start == IMX8MQ_PCIE2_BASE_ADDR)
 			imx6_pcie->controller_id = 1;
 
@@ -2573,7 +2680,9 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		}
 		break;
 	case IMX8QM:
+	case IMX8QM_EP:
 	case IMX8QXP:
+	case IMX8QXP_EP:
 		if (dbi_base->start == IMX8_HSIO_PCIEB_BASE_ADDR)
 			imx6_pcie->controller_id = 1;
 
@@ -2583,10 +2692,10 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 			return PTR_ERR(imx6_pcie->pcie_per);
 		}
 
-		imx6_pcie->pcie_inbound_axi = devm_clk_get(&pdev->dev,
+		imx6_pcie->pcie_inbound_axi = devm_clk_get(dev,
 				"pcie_inbound_axi");
 		if (IS_ERR(imx6_pcie->pcie_inbound_axi)) {
-			dev_err(&pdev->dev,
+			dev_err(dev,
 				"pcie clock source missing or invalid\n");
 			return PTR_ERR(imx6_pcie->pcie_inbound_axi);
 		}
@@ -2652,7 +2761,6 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		return PTR_ERR(imx6_pcie->clkreq_reset);
 	}
 
-
 	/* Grab GPR config register range */
 	if (imx6_pcie->iomuxc_gpr == NULL) {
 		imx6_pcie->iomuxc_gpr =
@@ -2664,39 +2772,69 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 	}
 
 	/* Grab PCIe PHY Tx Settings */
-	if (of_property_read_u32(node, "fsl,tx-deemph-gen1",
-				 &imx6_pcie->tx_deemph_gen1))
+	if ((imx6_pcie->drvdata->variant == IMX8MM) ||
+			(imx6_pcie->drvdata->variant == IMX8MQ)) {
+		/* reset defaults */
+		imx6_pcie->tx_deemph_gen1 = 24;
+		imx6_pcie->tx_deemph_gen2_3p5db = 24;
+		imx6_pcie->tx_deemph_gen2_6db = 35;
+		imx6_pcie->tx_swing_full = 127;
+		imx6_pcie->tx_swing_low = 127;
+	} else {
 		imx6_pcie->tx_deemph_gen1 = 0;
-
-	if (of_property_read_u32(node, "fsl,tx-deemph-gen2-3p5db",
-				 &imx6_pcie->tx_deemph_gen2_3p5db))
 		imx6_pcie->tx_deemph_gen2_3p5db = 0;
-
-	if (of_property_read_u32(node, "fsl,tx-deemph-gen2-6db",
-				 &imx6_pcie->tx_deemph_gen2_6db))
 		imx6_pcie->tx_deemph_gen2_6db = 20;
-
-	if (of_property_read_u32(node, "fsl,tx-swing-full",
-				 &imx6_pcie->tx_swing_full))
 		imx6_pcie->tx_swing_full = 127;
-
-	if (of_property_read_u32(node, "fsl,tx-swing-low",
-				 &imx6_pcie->tx_swing_low))
 		imx6_pcie->tx_swing_low = 127;
+	}
+
+	of_property_read_u32(node, "fsl,tx-deemph-gen1",
+				 &imx6_pcie->tx_deemph_gen1);
+	if (tx_deemph_gen1 >= 0)
+		imx6_pcie->tx_deemph_gen1 = tx_deemph_gen1;
+
+	of_property_read_u32(node, "fsl,tx-deemph-gen2-3p5db",
+				 &imx6_pcie->tx_deemph_gen2_3p5db);
+	if (tx_deemph_gen2_3p5db >= 0)
+		imx6_pcie->tx_deemph_gen2_3p5db = tx_deemph_gen2_3p5db;
+
+	of_property_read_u32(node, "fsl,tx-deemph-gen2-6db",
+				 &imx6_pcie->tx_deemph_gen2_6db);
+	if (tx_deemph_gen2_6db >= 0)
+		imx6_pcie->tx_deemph_gen2_6db = tx_deemph_gen2_6db;
+
+	of_property_read_u32(node, "fsl,tx-swing-full",
+				 &imx6_pcie->tx_swing_full);
+	if (tx_swing_full >= 0)
+		imx6_pcie->tx_swing_full = tx_swing_full;
+
+	of_property_read_u32(node, "fsl,tx-swing-low",
+				 &imx6_pcie->tx_swing_low);
+	if (tx_swing_low >= 0)
+		imx6_pcie->tx_swing_low = tx_swing_low;
 
 	/* Limit link speed */
 	ret = of_property_read_u32(node, "fsl,max-link-speed",
 				   &imx6_pcie->link_gen);
 	if (ret)
 		imx6_pcie->link_gen = 1;
+	if (link_gen > 0)
+		imx6_pcie->link_gen = link_gen;
 
-	imx6_pcie->vpcie = devm_regulator_get_optional(&pdev->dev, "vpcie");
+	imx6_pcie->vpcie = devm_regulator_get_optional(dev, "vpcie");
 	if (IS_ERR(imx6_pcie->vpcie)) {
 		if (PTR_ERR(imx6_pcie->vpcie) != -ENODEV)
 			return PTR_ERR(imx6_pcie->vpcie);
 		imx6_pcie->vpcie = NULL;
 	}
 
+	imx6_pcie->vph = devm_regulator_get_optional(&pdev->dev, "vph");
+	if (IS_ERR(imx6_pcie->vph)) {
+		if (PTR_ERR(imx6_pcie->vph) != -ENODEV)
+			return PTR_ERR(imx6_pcie->vph);
+		imx6_pcie->vph = NULL;
+	}
+
 	platform_set_drvdata(pdev, imx6_pcie);
 
 	ret = imx6_pcie_attach_pd(dev);
@@ -2708,230 +2846,25 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		dev_err(dev, "failed to enable the epdev_on regulator\n");
 		goto err_ret;
 	}
+	if (gpio_is_valid(imx6_pcie->dis_gpio))
+		gpio_set_value_cansleep(imx6_pcie->dis_gpio, 1);
 
-	if (IS_ENABLED(CONFIG_EP_MODE_IN_EP_RC_SYS)
-			&& (imx6_pcie->hard_wired == 0)) {
-		int i = 0, irq;
-		u32 val, tv_count1, tv_count2;
-		dma_addr_t test_reg1_dma, test_reg2_dma;
-		void *test_reg1, *test_reg2;
-		void __iomem *pcie_arb_base_addr;
-		struct timespec64 tv1s, tv1e, tv2s, tv2e;
-		struct resource_entry *win, *tmp;
-		LIST_HEAD(res);
-		struct pcie_port *pp = &pci->pp;
-		unsigned long timeout = jiffies + msecs_to_jiffies(300000);
-
-		/* add attributes for device */
-		imx6_pcie_attrgroup.attrs = imx6_pcie_ep_attrs;
-		ret = sysfs_create_group(&pdev->dev.kobj, &imx6_pcie_attrgroup);
-		if (ret)
-			return -EINVAL;
-
-		ret = devm_of_pci_get_host_bridge_resources(dev, 0, 0xff, &res,
-							    &pp->io_base);
-		if (ret)
-			return ret;
-
-		ret = devm_request_pci_bus_resources(&pdev->dev, &res);
-		if (ret) {
-			dev_err(dev, "missing ranges property\n");
-			pci_free_resource_list(&res);
-			return ret;
-		}
-
-		/* Get the I/O and memory ranges from DT */
-		resource_list_for_each_entry_safe(win, tmp, &res) {
-			switch (resource_type(win->res)) {
-			case IORESOURCE_MEM:
-				pp->mem = win->res;
-				pp->mem->name = "MEM";
-				pp->mem_size = resource_size(pp->mem);
-				pp->mem_bus_addr = pp->mem->start - win->offset;
-				break;
-			}
-		}
-
-		pp->mem_base = pp->mem->start;
-		pp->ops = &imx6_pcie_host_ops;
-		dev_info(dev, " try to initialize pcie ep.\n");
-		ret = imx6_pcie_host_init(pp);
-		if (ret) {
-			dev_info(dev, " fail to initialize pcie ep.\n");
-			return ret;
-		}
-
-		dw_pcie_dbi_ro_wr_en(pci);
-		switch (imx6_pcie->drvdata->variant) {
-		case IMX8MQ:
-		case IMX8MM:
-		case IMX8MP:
-			imx6_pcie_setup_ep(pci, SZ_1M);
-			break;
-		default:
-			imx6_pcie_setup_ep(pci, SZ_4K);
-			break;
-		}
-		pci_imx_set_msi_en(pp);
-		platform_set_drvdata(pdev, imx6_pcie);
-		imx6_pcie_regions_setup(dev);
-
-		/*
-		 * iMX6SX PCIe has the stand-alone power domain.
-		 * refer to the initialization for iMX6SX PCIe,
-		 * release the PCIe PHY reset here,
-		 * before LTSSM enable is set.
-		 */
-		if (imx6_pcie->drvdata->variant == IMX6SX)
-			regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR5,
-					BIT(19), 0 << 19);
-
-		/* assert LTSSM enable */
-		imx6_pcie_ltssm_enable(dev);
-
-		dev_info(dev, "PCIe EP: waiting for link up...\n");
-		/* link is indicated by the bit4 of DB_R1 register */
-		do {
-			usleep_range(10, 20);
-			if (time_after(jiffies, timeout)) {
-				dev_info(dev, "PCIe EP: link down.\n");
-				return 0;
-			}
-			val = readl(pci->dbi_base + PCIE_PHY_DEBUG_R1);
-		} while ((val & 0x10) == 0);
-
-		/* self io test */
-		/* Check the DMA INT exist or not */
-		irq =  platform_get_irq_byname(pdev, "dma");
-		if (irq > 0)
-			dma_en = 1;
-		else
-			dma_en = 0;
-		if (dma_en) {
-			/* configure the DMA INT ISR */
-			ret = request_irq(irq, imx6_pcie_dma_isr,
-					  IRQF_SHARED, "imx-pcie-dma", pp);
-			if (ret) {
-				pr_err("register interrupt %d failed, rc %d\n",
-					irq, ret);
-				dma_en = 0;
-			}
-			test_reg1 = dma_alloc_coherent(dev, test_region_size,
-					&test_reg1_dma, GFP_KERNEL);
-			test_reg2 = dma_alloc_coherent(dev, test_region_size,
-					&test_reg2_dma, GFP_KERNEL);
-			if (!(test_reg1 && test_reg2))
-				dma_en = 0; /* Roll back to PIO. */
-			dma_r_end = dma_w_end = 0;
-
-			val = readl(pci->dbi_base + DMA_CTRL_VIEWPORT_OFF);
-			if (val == 0xffffffff)
-				imx6_pcie->dma_unroll_offset =
-					DMA_UNROLL_CDM_OFFSET - DMA_REG_OFFSET;
-			else
-				imx6_pcie->dma_unroll_offset = 0;
-		}
-
-		if (unlikely(dma_en == 0)) {
-			test_reg1 = devm_kzalloc(&pdev->dev,
-					test_region_size, GFP_KERNEL);
-			if (!test_reg1) {
-				ret = -ENOMEM;
-				return ret;
-			}
-
-			test_reg2 = devm_kzalloc(&pdev->dev,
-					test_region_size, GFP_KERNEL);
-			if (!test_reg2) {
-				ret = -ENOMEM;
-				return ret;
-			}
-		}
-
-		pcie_arb_base_addr = ioremap_nocache(pp->mem_base,
-					test_region_size);
-		if (!pcie_arb_base_addr) {
-			dev_err(dev, "ioremap error in ep io test\n");
-			ret = -ENOMEM;
-			return ret;
-		}
-
-		for (i = 0; i < test_region_size; i = i + 4) {
-			writel(0xE6600D00 + i, test_reg1 + i);
-			writel(0xDEADBEAF, test_reg2 + i);
-		}
+	imx6_pcie_assert_core_reset(imx6_pcie);
+	imx6_pcie_init_phy(imx6_pcie);
+	imx6_pcie_deassert_core_reset(imx6_pcie);
+	imx6_setup_phy_mpll(imx6_pcie);
 
-		/* PCIe EP start the data transfer after link up */
-		dev_info(dev, "pcie ep: Starting data transfer...\n");
-		ktime_get_real_ts64(&tv1s);
-
-
-		/* EP write the test region to remote RC's DDR memory */
-		if (dma_en) {
-			imx6_pcie_local_dma_start(pp, 0, 0, test_reg1_dma,
-			imx6_pcie_cpu_addr_fixup(imx6_pcie->pci, pp->mem_base),
-					test_region_size);
-			timeout = jiffies + msecs_to_jiffies(300);
-			do {
-				udelay(1);
-				if (time_after(jiffies, timeout)) {
-					dev_info(dev, "dma write no end ...\n");
-					break;
-				}
-			} while (!dma_w_end);
-		} else {
-			memcpy((unsigned int *)pcie_arb_base_addr,
-					(unsigned int *)test_reg1,
-					test_region_size);
-		}
+	val = dw_pcie_readl_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF);
+	val |= 0xD;
+	dw_pcie_writel_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF, val);
 
-		ktime_get_real_ts64(&tv1e);
-
-		ktime_get_real_ts64(&tv2s);
-		/* EP read the test region back from remote RC's DDR memory */
-		if (dma_en) {
-			imx6_pcie_local_dma_start(pp, 1, 0,
-			imx6_pcie_cpu_addr_fixup(imx6_pcie->pci, pp->mem_base),
-					test_reg2_dma, test_region_size);
-			timeout = jiffies + msecs_to_jiffies(300);
-			do {
-				udelay(1);
-				if (time_after(jiffies, timeout)) {
-					dev_info(dev, "dma read no end\n");
-					break;
-				}
-			} while (!dma_r_end);
-		} else {
-			memcpy((unsigned int *)test_reg2,
-					(unsigned int *)pcie_arb_base_addr,
-					test_region_size);
-		}
+	switch (imx6_pcie->drvdata->mode) {
+	case DW_PCIE_RC_TYPE:
+		/* add attributes for bus freq */
+		ret = sysfs_create_group(&pdev->dev.kobj, &imx_pcie_attrgroup);
+		if (ret)
+			goto err_ret;
 
-		ktime_get_real_ts64(&tv2e);
-		if (memcmp(test_reg2, test_reg1, test_region_size) == 0) {
-			tv_count1 = (tv1e.tv_sec - tv1s.tv_sec)
-				* USEC_PER_SEC
-				+ (tv1e.tv_nsec - tv1s.tv_nsec) / 1000;
-			tv_count2 = (tv2e.tv_sec - tv2s.tv_sec)
-				* USEC_PER_SEC
-				+ (tv2e.tv_nsec - tv2s.tv_nsec) / 1000;
-
-			dev_info(dev, "ep: Data %s transfer is successful.\n",
-					dma_en ? "DMA" : "PIO");
-			dev_info(dev, "ep: Data write %dus speed:%ldMB/s.\n",
-					tv_count1,
-					((test_region_size/1024)
-					   * MSEC_PER_SEC)
-					/(tv_count1));
-			dev_info(dev, "ep: Data read %dus speed:%ldMB/s.\n",
-					tv_count2,
-					((test_region_size/1024)
-					   * MSEC_PER_SEC)
-					/(tv_count2));
-		} else {
-			dev_info(dev, "ep: Data transfer is failed.\n");
-		} /* end of self io test. */
-	} else {
 		ret = imx6_add_pcie_port(imx6_pcie, pdev);
 		if (ret < 0) {
 			if (IS_ENABLED(CONFIG_PCI_IMX6_COMPLIANCE_TEST)) {
@@ -2945,44 +2878,17 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 		}
 		pci_imx_set_msi_en(&imx6_pcie->pci->pp);
 
-		if (IS_ENABLED(CONFIG_RC_MODE_IN_EP_RC_SYS)
-				&& (imx6_pcie->hard_wired == 0))
-			imx6_pcie_regions_setup(&pdev->dev);
+		break;
+	case DW_PCIE_EP_TYPE:
+		if (!IS_ENABLED(CONFIG_PCI_IMX_EP))
+			ret = -ENODEV;
 
-		/*
-		 * If the L1SS is enabled, disable the over ride after link up.
-		 * Let the the CLK_REQ# controlled by HW L1SS automatically.
-		 */
-		ret = imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_L1SS;
-		if (IS_ENABLED(CONFIG_PCIEASPM_POWER_SUPERSAVE) && (ret > 0)) {
-			switch (imx6_pcie->drvdata->variant) {
-			case IMX8MQ:
-			case IMX8MM:
-			case IMX8MP:
-				regmap_update_bits(imx6_pcie->iomuxc_gpr,
-					imx6_pcie_grp_offset(imx6_pcie),
-					IMX8MQ_GPR_PCIE_CLK_REQ_OVERRIDE_EN,
-					0);
-				break;
-			case IMX8QXP:
-				regmap_update_bits(imx6_pcie->iomuxc_gpr,
-					IMX8QM_CSR_MISC_OFFSET,
-					IMX8QM_MISC_CLKREQ_OVERRIDE_EN_1,
-					0);
-				break;
-			case IMX8QM:
-				if (imx6_pcie->controller_id)
-					reg = IMX8QM_MISC_CLKREQ_OVERRIDE_EN_1;
-				else
-					reg = IMX8QM_MISC_CLKREQ_OVERRIDE_EN_0;
-				regmap_update_bits(imx6_pcie->iomuxc_gpr,
-					IMX8QM_CSR_MISC_OFFSET,
-					reg, 0);
-				break;
-			default:
-				break;
-			};
-		}
+		ret = imx_add_pcie_ep(imx6_pcie, pdev);
+		if (ret < 0)
+			goto err_ret;
+		break;
+	default:
+		dev_err(dev, "INVALID device type.\n");
 	}
 
 	return 0;
@@ -3003,6 +2909,7 @@ static void imx6_pcie_shutdown(struct platform_device *pdev)
 static const struct imx6_pcie_drvdata drvdata[] = {
 	[IMX6Q] = {
 		.variant = IMX6Q,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_IMX6_PHY |
 			 IMX6_PCIE_FLAG_SUPPORTS_SUSPEND |
 			 IMX6_PCIE_FLAG_IMX6_SPEED_CHANGE,
@@ -3010,43 +2917,93 @@ static const struct imx6_pcie_drvdata drvdata[] = {
 	},
 	[IMX6SX] = {
 		.variant = IMX6SX,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_IMX6_PHY |
 			 IMX6_PCIE_FLAG_IMX6_SPEED_CHANGE |
 			 IMX6_PCIE_FLAG_SUPPORTS_SUSPEND,
 	},
 	[IMX6QP] = {
 		.variant = IMX6QP,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_IMX6_PHY |
 			 IMX6_PCIE_FLAG_IMX6_SPEED_CHANGE |
 			 IMX6_PCIE_FLAG_SUPPORTS_SUSPEND,
 	},
 	[IMX7D] = {
 		.variant = IMX7D,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND,
 	},
 	[IMX8MQ] = {
 		.variant = IMX8MQ,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND |
 			 IMX6_PCIE_FLAG_SUPPORTS_L1SS,
 	},
 	[IMX8MM] = {
 		.variant = IMX8MM,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND |
 			 IMX6_PCIE_FLAG_SUPPORTS_L1SS,
 	},
 	[IMX8QM] = {
 		.variant = IMX8QM,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND |
 			 IMX6_PCIE_FLAG_IMX6_CPU_ADDR_FIXUP,
 	},
 	[IMX8QXP] = {
 		.variant = IMX8QXP,
+		.mode = DW_PCIE_RC_TYPE,
 		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND |
 			 IMX6_PCIE_FLAG_IMX6_CPU_ADDR_FIXUP,
 	},
 	[IMX8MP] = {
 		.variant = IMX8MP,
-		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND,
+		.mode = DW_PCIE_RC_TYPE,
+		.flags = IMX6_PCIE_FLAG_SUPPORTS_SUSPEND |
+			 IMX6_PCIE_FLAG_SUPPORTS_L1SS,
+	},
+	[IMX8QXP_EP] = {
+		.variant = IMX8QXP_EP,
+		.mode = DW_PCIE_EP_TYPE,
+		.flags = IMX6_PCIE_FLAG_IMX6_CPU_ADDR_FIXUP,
+	},
+	[IMX8QM_EP] = {
+		.variant = IMX8QM_EP,
+		.mode = DW_PCIE_EP_TYPE,
+		.flags = IMX6_PCIE_FLAG_IMX6_CPU_ADDR_FIXUP,
+	},
+	[IMX8MQ_EP] = {
+		.variant = IMX8MQ_EP,
+		.mode = DW_PCIE_EP_TYPE,
+	},
+	[IMX8MM_EP] = {
+		.variant = IMX8MM_EP,
+		.mode = DW_PCIE_EP_TYPE,
+	},
+	[IMX8MP_EP] = {
+		.variant = IMX8MP_EP,
+		.mode = DW_PCIE_EP_TYPE,
+	},
+	[IMX6SX_EP] = {
+		.variant = IMX6SX_EP,
+		.mode = DW_PCIE_EP_TYPE,
+		.flags = IMX6_PCIE_FLAG_IMX6_PHY,
+	},
+	[IMX7D_EP] = {
+		.variant = IMX7D_EP,
+		.mode = DW_PCIE_EP_TYPE,
+	},
+	[IMX6Q_EP] = {
+		.variant = IMX6Q_EP,
+		.mode = DW_PCIE_EP_TYPE,
+		.flags = IMX6_PCIE_FLAG_IMX6_PHY,
+	},
+	[IMX6QP_EP] = {
+		.variant = IMX6QP_EP,
+		.mode = DW_PCIE_EP_TYPE,
+		.flags = IMX6_PCIE_FLAG_IMX6_PHY,
 	},
 };
 
@@ -3060,6 +3017,15 @@ static const struct of_device_id imx6_pcie_of_match[] = {
 	{ .compatible = "fsl,imx8qm-pcie", .data = &drvdata[IMX8QM], },
 	{ .compatible = "fsl,imx8qxp-pcie", .data = &drvdata[IMX8QXP], },
 	{ .compatible = "fsl,imx8mp-pcie", .data = &drvdata[IMX8MP], },
+	{ .compatible = "fsl,imx8qxp-pcie-ep", .data = &drvdata[IMX8QXP_EP], },
+	{ .compatible = "fsl,imx8qm-pcie-ep", .data = &drvdata[IMX8QM_EP], },
+	{ .compatible = "fsl,imx8mq-pcie-ep", .data = &drvdata[IMX8MQ_EP], },
+	{ .compatible = "fsl,imx8mm-pcie-ep", .data = &drvdata[IMX8MM_EP], },
+	{ .compatible = "fsl,imx8mp-pcie-ep", .data = &drvdata[IMX8MP_EP], },
+	{ .compatible = "fsl,imx6sx-pcie-ep", .data = &drvdata[IMX6SX_EP], },
+	{ .compatible = "fsl,imx7d-pcie-ep", .data = &drvdata[IMX7D_EP], },
+	{ .compatible = "fsl,imx6q-pcie-ep", .data = &drvdata[IMX6Q_EP], },
+	{ .compatible = "fsl,imx6qp-pcie-ep", .data = &drvdata[IMX6QP_EP], },
 	{},
 };
 
@@ -3106,6 +3072,58 @@ static void imx6_pcie_quirk(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_CLASS_HEADER(PCI_VENDOR_ID_SYNOPSYS, 0xabcd,
 			PCI_CLASS_BRIDGE_PCI, 8, imx6_pcie_quirk);
 
+static void imx6_pcie_l1ss_quirk(struct pci_dev *dev)
+{
+	u32 reg, rc_l1sub, ep_l1sub, header;
+	int ttl, ret;
+	int pos = PCI_CFG_SPACE_SIZE;
+	struct pci_bus *bus = dev->bus;
+	struct pcie_port *pp = bus->sysdata;
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pci);
+
+	/* Return directly, if the L1SS is not supported by RC */
+	if (!(imx6_pcie->drvdata->flags & IMX6_PCIE_FLAG_SUPPORTS_L1SS))
+		return;
+
+	/* Make sure the L1SS is not force disabled. */
+	if (imx6_pcie->l1ss_clkreq == 0)
+		return;
+
+	reg = dw_pcie_find_ext_capability(pci, PCI_EXT_CAP_ID_L1SS);
+	rc_l1sub = dw_pcie_readl_dbi(pci, reg + PCI_L1SS_CAP);
+
+	/* minimum 8 bytes per capability */
+	ttl = (PCI_CFG_SPACE_EXP_SIZE - PCI_CFG_SPACE_SIZE) / 8;
+	ret = dw_pcie_read(pp->va_cfg0_base + pos, 4, &header);
+	/*
+	 * If we have no capabilities, this is indicated by cap ID,
+	 * cap version and next pointer all being 0.
+	 */
+	if (header == 0)
+		return;
+
+	while (ttl-- > 0) {
+		if (PCI_EXT_CAP_ID(header) == PCI_EXT_CAP_ID_L1SS && pos != 0)
+			break;
+
+		pos = PCI_EXT_CAP_NEXT(header);
+		if (pos < PCI_CFG_SPACE_SIZE)
+			break;
+
+		ret = dw_pcie_read(pp->va_cfg0_base + pos, 4, &header);
+	}
+	ret = dw_pcie_read(pp->va_cfg0_base + pos + PCI_L1SS_CAP, 4, &ep_l1sub);
+
+	if ((rc_l1sub && ep_l1sub) && PCI_L1SS_CAP_L1_PM_SS) {
+		imx6_pcie->l1ss_clkreq = 1;
+		imx6_pcie_clkreq_enable(imx6_pcie);
+	} else {
+		imx6_pcie->l1ss_clkreq = 0;
+	}
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SYNOPSYS, 0xabcd, imx6_pcie_l1ss_quirk);
+
 static int __init imx6_pcie_init(void)
 {
 #ifdef CONFIG_ARM
@@ -3123,3 +3141,4 @@ static int __init imx6_pcie_init(void)
 	return platform_driver_register(&imx6_pcie_driver);
 }
 device_initcall(imx6_pcie_init);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pci/controller/dwc/pcie-designware.h b/drivers/pci/controller/dwc/pcie-designware.h
index 5a18e94e52c8..541878ad37d8 100644
--- a/drivers/pci/controller/dwc/pcie-designware.h
+++ b/drivers/pci/controller/dwc/pcie-designware.h
@@ -60,6 +60,7 @@
 #define PCIE_MSI_INTR0_MASK		0x82C
 #define PCIE_MSI_INTR0_STATUS		0x830
 
+#define PCIE_AMBA_ORDERING_CTRL_OFF	0x8D8
 #define PCIE_ATU_VIEWPORT		0x900
 #define PCIE_ATU_REGION_INBOUND		BIT(31)
 #define PCIE_ATU_REGION_OUTBOUND	0
-- 
2.11.0

